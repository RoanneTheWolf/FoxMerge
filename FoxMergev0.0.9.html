<!DOCTYPE html>
<style>

    body {
        background-color: #222222;
        color: #ffffff;
        overflow: hidden;
    }

    .alwaysPointer {
        cursor: pointer;
        overflow: hidden;
    }

    .noDisplay {
        display: none;
        overflow: hidden;
    }

    a {
        cursor:pointer
    }

    .testingButtons {
        padding:5px;
    }

    .buttonGrid {
        float: left;
        width: 114px;
        height: 114px;
        margin-top: 10px;
    }

    .zoomButton {
        border: 1.5px solid dimgrey;
        border-radius: 5px;
        float: left;
        width: 30px;
        height: 30px;
        margin-right: 5px;
        margin-bottom: 5px;
        font-size: 30px;
        line-height: 30px;
        text-align: center;
        fill: dimgrey;
        cursor: default;
    }

    .activeButton {
        border-color: white;
        fill: white;
        cursor: pointer;
    }

    .centerColumn {
        width: 804px;
        margin: auto;
        position: relative;
    }

    #infoBox {
        height: 510px;
        width: calc(50vw - 500px);
        padding: 10px;
        border: 2px solid white;
        border-radius: 30px;
        overflow: hidden;
        position: absolute;
        z-index: 2;
        top: 0px;
        transition-property: right;
        transition-duration: 1.2s;
        transition-timing-function: ease;
    }

    .infoOut {
        right: calc(450px - 50vw);
    }

    .infoIn {
        right: 10px;
    }

    .outerFoxBox {
        height: 510px;
        width: 780px;
        margin: auto;
        padding: 10px;
        border: 2px solid white;
        border-radius: 30px;
        overflow: hidden;
        position: relative;
        z-index: 3;
        background-color: #222222;
    }

        .innerFoxBox {
            height: 150px;
            width: 240px;
            border: 2px solid white;
            border-radius: 20px;
            margin: 10px 10px;
            float: right;
            box-sizing: border-box;
            overflow: hidden;
        }

        .foxLayerWrapper {
            height: 510px;
            width: 780px;
            border-radius: 20px;
            transform-origin: 10px 500px;
            overflow: hidden;
            position: absolute;
        }

        .foxProgressHousing {
            width: 800px;
            height: 20px;
            border: 2px solid white;
            border-radius: 20px;
            margin-top: 20px;
            overflow: hidden;
        }

        #foxProgressBar {
            height: 100%;
            float: left;
        }

        .mergeProgressHousing {
            width: 800px;
            height: 5px;
            border: 2px solid white;
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
        }

        #mergeProgressBar {
            height: 100%;
            float: left;
        }

        .foxPlaceholder {
            font-family: arial;
            font-size: 40px;
            text-align: center;
            line-height: 140px;
            cursor: pointer;
        }

        .layingSVG {
            width: 236px;
            height: 146px;
            shape-rendering: optimizeSpeed;
        }

    .hangingSVG {
        position: relative;
        width: 100vw;
        height: 100vh;
        shape-rendering: optimizeSpeed;
        overflow: hidden;
    }

        .wholeFox {
            cursor: pointer;
        }

        #held {
            z-index: 10;
        }

        .moving {
            position: absolute;
            left: 0px;
            top: 0px;
            pointer-events: none;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            z-index: 5;
        }
</style>
<meta name="viewport" content="height=700, initial-scale=1" />
<div class="centerColumn">
    <div class="outerFoxBox" id="outerFoxBox">
        <div class="foxLayerWrapper" id="foxLayerWrapper0">
            <div class="innerFoxBox" id="foxBox0"></div>
            <div class="innerFoxBox" id="foxBox1"></div>
            <div class="innerFoxBox" id="foxBox2"></div>
            <div class="innerFoxBox" id="foxBox3"></div>
            <div class="innerFoxBox" id="foxBox4"></div>
            <div class="innerFoxBox" id="foxBox5"></div>
            <div class="innerFoxBox" id="foxBox6"></div>
            <div class="innerFoxBox" id="foxBox7"></div>
            <div class="innerFoxBox" id="foxBox8"></div>
        </div>
    </div>
    <div id="infoBox"> Hello</div>
    <div class="foxProgressHousing">
        <div id="foxProgressBar"></div>
    </div>
    <div class="mergeProgressHousing">
        <div id="mergeProgressBar"></div>
    </div>
    <div class="buttonGrid">
        <div class="zoomButton" id="buttonZI" onclick="zoomIn()">
            <svg viewBox="0 0 100 100" style="fill:inherit">
                <path d="M 72.5,67.5 77.5,62.5 62.5,62.5 62.5,77.5 67.5,72.5 82.5,87.5 87.5,82.5 Z M 67.5,27.5 62.5,22.5 62.5,37.5 77.5,37.5 72.5,32.5 87.5,17.5 82.5,12.5 Z M 27.5,32.5 22.5,37.5 37.5,37.5 37.5,22.5 32.5,27.5 17.5,12.5 12.5,17.5 Z M 32.5,72.5 37.5,77.5 37.5,62.5 22.5,62.5 27.5,67.5 12.5,82.5 17.5,87.5 Z" />
            </svg>
        </div>
        <div class="zoomButton" id="buttonZU" onclick="zoomUp()">
            <svg viewBox="0 0 100 100" style="fill:inherit">
                    <path d="M 30,40 H 45 V 80 L 55,80 V 40 H 70 L 50,20 Z"/>
            </svg>
        </div>
        <div class="zoomButton" id="buttonZO" onclick="zoomOut()">
            <svg viewBox="0 0 100 100" style="fill:inherit">
                <path d="M 77.5,82.5 72.5,87.5 87.5,87.5 87.5,72.5 82.5,77.5 67.5,62.5 62.5,67.5 Z M 82.5,22.5 87.5,27.5 87.5,12.5 72.5,12.5 77.5,17.5 62.5,32.5 67.5,37.5 Z M 22.5,17.5 27.5,12.5 12.5,12.5 12.5,27.5 17.5,22.5 32.5,37.5 37.5,32.5 Z M 17.5,77.5 12.5,72.5 12.5,87.5 27.5,87.5 22.5,82.5 37.5,67.5 32.5,62.5 Z" />
            </svg>
        </div>
        <div class="zoomButton" id="buttonZL" onclick="zoomLeft()">
            <svg viewBox="0 0 100 100" style="fill:inherit">
                <path d="M 40,30 V 45 H 80 L 80,55 H 40 V 70 L 20,50 Z" />
            </svg>
        </div>
        <div class="zoomButton" id="buttonZD" onclick="zoomDown()">
            <svg viewBox="0 0 100 100" style="fill:inherit">
                <path d="M 70,60 H 55 V 20 L 45,20 V 60 H 30 L 50,80 Z" />
            </svg>
        </div>
        <div class="zoomButton" id="buttonZR" onclick="zoomRight()">
            <svg viewBox="0 0 100 100" style="fill:inherit">
                <path d="M 60,70 V 55 H 20 L 20,45 H 60 V 30 L 80,50 Z" />
            </svg>
        </div>
    </div>
    <div class="testingButtons">
        <a onclick="advanceTime(1)">Find Some Foxes</a> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     <a onclick="normalMode()">Enable Automerge</a> | <a onclick="quickMode()">Disable Automerge</a>
        <!-- |
    <a onclick="sillyMode()">Silly Mode</a>-->
        <br />Click and drag foxes onto each other to make them grow.
        <br />QWEASD to zoom, or use the buttons.
        <br />Past a certain size the display glitches for full zoom.
        <br />There is no other limit.
    </div>
</div>
<div id="movingContainer"><div class="moving" id="held"></div></div>


<!---</div>-->
<div class="noDisplay">
    <svg viewBox="-118 -145.7 236 146"
         id="layingTemplate1"
         class="layingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignStartpoint" d="M -3.6694,-12.702 C -2.3387,-15.758 -5.5603,-17.458 -8.7086,-17.46 -17.5021,-17.466 -20.6722,-9.959 -18.4449,-8.902 -18.5756,-7.656 -18.4734,-6.459 -18.2,-5.45 -17.7237,-3.693 -16.8395,-2.334 -15.7423,-1.302 -15.9091,-0.442 -15.1423,0 -14.7148,0 L 0,0 0,-13.732" />
            <path class="toSquish alignStartpoint" d="M 3.6695,-12.702 C 2.3388,-15.758 5.5604,-17.458 8.7086,-17.46 17.5021,-17.466 20.6722,-9.959 18.445,-8.902 18.5757,-7.656 18.4735,-6.459 18.2,-5.45 17.7238,-3.693 16.8395,-2.334 15.7423,-1.302 15.9091,-0.442 15.1422,0 14.7147,0 L 0,0 0,-13.732" />
            <path class="toRaise" d="M -3.3254,-18.831 C -3.3254,-18.831 0.3133,-12.994 3.1646,-19.052 3.1646,-19.052 19.8218,-39.974 19.7739,-50.857 19.769,-61.741 8.5891,-70.796 -5.7982,-70.227 -20.1856,-69.655 -30.7522,-47.935 -30.7522,-47.935 -30.7522,-47.935 -8.366,-61.929 2.3185,-47.283 13.003,-32.634 -3.3254,-18.837 -3.3254,-18.837 Z" />
            <path class="toRaise" d="M 11.0953,-12.996 C 18.6535,-15.479 21.719,-14.842 21.7171,-18.936 21.7152,-23.03 18.365,-22.382 10.7986,-24.856 7.6527,-25.885 3.3885,-27.901 0.025,-27.9 -3.3374,-27.898 -7.6008,-25.876 -10.7467,-24.843 -18.3079,-22.362 -21.6608,-23.147 -21.6589,-18.915 -21.6569,-14.681 -18.5951,-15.47 -11.0317,-12.996" />
            <g style="fill: #ff5555" class="braColor">
                <path class="toSquish isLayingBra" d="M 0,-27.899606 C 0,-27.899606 -17.988269,-4.768764 -18.444951,-8.90193 -18.575645,-7.65586 -18.473432,-6.458417 -18.200038,-5.449851 -17.723673,-3.693049 -16.839483,-2.333852 -15.742301,-1.30147 -17.988269,-4.768764 0,-27.899606 0,-27.899606 Z" />
                <path class="toSquish" d="M -18.200038,-5.449851 C -18.327258,-4.768102 -18.13001,-4.250754 -17.65917,-3.95867" />
                <path class="toSquish isLayingBra" d="M 0,-27.899506 C 0,-27.899506 17.988669,-4.768664 18.445351,-8.90183 18.576045,-7.65576 18.473832,-6.458317 18.200438,-5.449751 17.724073,-3.692949 16.839883,-2.333752 15.742701,-1.30137 17.988669,-4.768664 0,-27.899506 0,-27.899506 Z" />
                <path class="toSquish" d="M 18.200438,-5.449751 C 18.327658,-4.768002 18.13041,-4.250654 17.65957,-3.95857" />
            </g>
            <path class="toRaise" d="M 8.368314,-21.121584 C 8.216793,-17.221127 6.652886,-16.401554 5.279342,-14.896221 3.972271,-13.463699 3.806063,-11.789147 3.514046,-9.703673 3.359871,-8.602685 2.446749,-5.936748 1.342926,-5.936205 L 0.032045,-5.935561 -1.278836,-5.934918 C -2.38265,-5.934375 -3.298217,-8.599414 -3.453398,-9.700251 -3.747286,-11.785437 -3.915024,-13.459825 -5.223429,-14.891063 -6.598348,-16.395045 -8.162995,-17.213081 -8.318088,-21.113388 -8.473173,-25.013609 -4.584158,-29.438456 0.021306,-29.440719 4.626778,-29.442981 8.519852,-25.021956 8.368314,-21.121584 Z" />
            <path class="toRaise" d="M 7.2787,-20.527604 8.751229,-15.341189 2.931239,-19.318005 C 3.896996,-20.443394 5.328458,-20.872958 7.2787,-20.527604 Z" />
            <path class="toRaise" d="M -7.26719,-20.481285 -8.734979,-15.293426 -2.918625,-19.275957 C -3.885411,-20.400397 -5.317264,-20.828555 -7.26719,-20.481285 Z" />
        </g>
    </svg>


    <svg viewBox="-118 -145.7 236 146"
         id="layingTemplate2"
         class="layingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignStartpoint" d="M -5.437,-18.821001 C -3.4652,-23.349001 -8.2387,-25.868001 -12.9034,-25.871001 -25.9326,-25.879001 -30.6297,-14.756001 -27.3296,-13.190001 -27.5232,-11.344 -27.3718,-9.57 -26.9667,-8.075 -26.2609,-5.472 -24.9508,-3.458 -23.3251,-1.929 -23.5722,-0.655 -22.436,-0.017 -21.8026,0 H 0 V -20.347001" />
            <path class="toSquish alignStartpoint" d="M 5.4371,-18.821001 C 3.4653,-23.349001 8.2387,-25.868001 12.9034,-25.871001 25.9326,-25.879001 30.629702,-14.756001 27.3296,-13.190001 27.5233,-11.344 27.3719,-9.57 26.9667,-8.075 26.261,-5.472 24.9508,-3.458 23.3251,-1.929 23.5723,-0.655 22.436,-0.017 21.8026,0 H 0 V -20.347001" />
            <path class="toRaise" d="M -3.3259,-23.068001 C -3.3259,-23.068001 0.3128,-17.231001 3.1641,-23.289001 3.1641,-23.289001 19.8213,-44.211001 19.7734,-55.094001 19.7685,-65.978001 8.5886,-75.033001 -5.7987,-74.464001 -20.1861,-73.892001 -30.7527,-52.172001 -30.7527,-52.172001 -30.7527,-52.172001 -8.3665,-66.166001 2.318,-51.520001 13.0025,-36.871001 -3.3259,-23.074001 -3.3259,-23.074001 Z" />
            <path class="toRaise" d="M 11.0948,-17.233001 C 18.653,-19.716001 21.7185,-19.079001 21.7166,-23.173001 21.7147,-27.267001 18.3645,-26.619001 10.7981,-29.093001 7.6522,-30.122001 3.388,-32.138001 0.0245,-32.137001 -3.3379,-32.135001 -7.6013,-30.113001 -10.7472,-29.080001 -18.3084,-26.599001 -21.6613,-27.384001 -21.6594,-23.152001 -21.6574,-18.918001 -18.5956,-19.707001 -11.0322,-17.233001" />
            <g style="fill: #9955ff" class="braColor">
                <path class="toSquish isLayingBra" d="M 0.02454,-32.137446 C 0.02454,-32.137446 -26.65301,-7.066365 -27.32967,-13.190408 -27.52331,-11.344128 -27.37187,-9.569895 -26.96678,-8.075521 -26.26096,-5.472496 -24.95087,-3.458595 -23.3252,-1.928933 -26.65301,-7.066365 0.02454,-32.137446 0.02454,-32.137446 Z" />
                <path class="toSquish" d="M -26.96678,-8.075521 C -27.15528,-7.065385 -26.86302,-6.298838 -26.16539,-5.866062" />
                <path class="toSquish isLayingBra" d="M 0.02802,-32.137346 C 0.02802,-32.137346 26.65332,-7.066265 27.32998,-13.190308 27.52362,-11.344028 27.37218,-9.569795 26.96709,-8.075421 26.26127,-5.472396 24.95118,-3.458495 23.3255,-1.928833 26.65332,-7.066265 0.02802,-32.137346 0.02802,-32.137346 Z" />
                <path class="toSquish" d="M 26.96709,-8.075421 C 27.15559,-7.065285 26.86333,-6.298738 26.1657,-5.865962" />
            </g>
            <path class="toRaise" d="M 8.36782,-25.359385 C 8.2163,-21.458928 6.65239,-20.639354 5.27885,-19.134022 3.97178,-17.701499 3.80557,-16.026947 3.51355,-13.941474 3.35938,-12.840485 2.44625,-10.174548 1.34243,-10.174006 L 0.03155,-10.173362 -1.27933,-10.172718 C -2.38315,-10.172176 -3.29871,-12.837215 -3.45389,-13.938051 -3.74778,-16.023237 -3.91552,-17.697625 -5.22392,-19.128863 -6.59884,-20.632845 -8.16349,-21.450882 -8.31858,-25.351189 -8.47367,-29.25141 -4.58465,-33.676257 0.02081,-33.67852 4.62628,-33.680782 8.51936,-29.259757 8.36782,-25.359385 Z" />
            <path class="toRaise" d="M 7.2782,-24.765405 8.75073,-19.57899 2.93074,-23.555806 C 3.8965,-24.681194 5.32796,-25.110759 7.2782,-24.765405 Z" />
            <path class="toRaise" d="M -7.26769,-24.719085 -8.73547,-19.531226 -2.91912,-23.513758 C -3.88591,-24.638197 -5.31776,-25.066355 -7.26769,-24.719085 Z" />
        </g>
    </svg>

    <svg viewBox="-118 -145.7 236 146"
         id="layingTemplate3"
         class="layingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignStartpoint" d="M 11.0681,-22.757 C 8.4081,-28.866 12.3613,-34.366 21.2528,-34.372 38.8295,-34.383 40.7692,-18.437 36.8683,-17.795 37.1297,-15.304 36.9253,-12.911 36.3789,-10.894 35.4269,-7.383 33.6594,-4.666 31.4662,-2.602 31.7995,-0.885 30.2669,-0.024 29.4123,0 H 0 L 0.0018,-27.449" />
            <path class="toSquish alignStartpoint" d="M -11.0663,-22.757 C -8.4063,-28.866 -12.3595,-34.366 -21.251,-34.372 -38.8277,-34.383 -40.7674,-18.437 -36.8665,-17.795 -37.1279,-15.304 -36.9235,-12.911 -36.3771,-10.894 -35.4251,-7.383 -33.6576,-4.666 -31.4644,-2.602 -31.7977,-0.885 -30.2651,-0.024 -29.4105,0 H 0.0018 L 0,-27.449" />
            <path class="toRaise" d="M -3.3526,-28.592 C -3.3526,-28.592 0.2861,-22.755 3.1374,-28.813 3.1374,-28.813 19.7946,-49.735 19.7467,-60.618 19.7418,-71.502 8.5619,-80.557 -5.8254,-79.988 -20.2128,-79.416 -30.7794,-57.696 -30.7794,-57.696 -30.7794,-57.696 -8.3932,-71.69 2.2913,-57.044 12.9758,-42.395 -3.3526,-28.598 -3.3526,-28.598 Z" />
            <path class="toRaise" d="M 11.0681,-22.757 C 18.6263,-25.24 21.6918,-24.603 21.6899,-28.697 21.688,-32.791 18.3378,-32.143 10.7714,-34.617 7.6255,-35.646 3.3613,-37.662 -0.0022,-37.661 -3.3646,-37.659 -7.628,-35.637 -10.7739,-34.604 -18.3351,-32.123 -21.688,-32.908 -21.6861,-28.676 -21.6841,-24.442 -18.6223,-25.231 -11.0589,-22.757" />
            <g style="fill: #3771c8" class="braColor">
                <path class="toSquish isLayingBra" d="M 0.0018014,-37.661009 C 0.0018014,-37.661009 -35.955812,-9.533441 -36.868647,-17.794975 -37.129882,-15.304283 -36.925575,-12.910785 -36.379104,-10.894825 -35.426928,-7.38326 -33.659575,-4.666441 -31.466483,-2.602875 -35.955812,-9.533441 0.0018014,-37.661009 0.0018014,-37.661009 Z" />
                <path class="toSquish" d="M -36.379104,-10.894825 C -36.633397,-9.532118 -36.239131,-8.498021 -35.297997,-7.914193" />
                <path class="toSquish isLayingBra" d="M 0.0017723,-37.660809 C 0.0017723,-37.660809 35.956212,-9.533241 36.869047,-17.794775 37.130282,-15.304083 36.925975,-12.910585 36.379504,-10.894625 35.427328,-7.38306 33.659975,-4.666241 31.466883,-2.602675 35.956212,-9.533241 0.0017723,-37.660809 0.0017723,-37.660809 Z" />
                <path class="toSquish" d="M 36.379504,-10.894625 C 36.633797,-9.531918 36.239531,-8.497821 35.298397,-7.913993" />
            </g>
            <path class="toRaise" d="M 8.3410142,-30.883084 C 8.1894934,-26.982627 6.6255858,-26.163054 5.2520422,-24.657721 3.9449712,-23.225199 3.7787625,-21.550647 3.4867462,-19.465173 3.3325707,-18.364185 2.4194487,-15.698248 1.3156256,-15.697705 L 0.0047448,-15.697061 -1.3061359,-15.696418 C -2.4099504,-15.695875 -3.3255166,-18.360914 -3.480698,-19.461751 -3.7745855,-21.546937 -3.9423242,-23.221325 -5.2507294,-24.652563 -6.6256478,-26.156545 -8.1902951,-26.974581 -8.3453885,-30.874888 -8.5004732,-34.775109 -4.6114576,-39.199956 -0.0059941,-39.202219 4.599478,-39.204481 8.4925522,-34.783456 8.3410142,-30.883084 Z" />
            <path class="toRaise" d="M 7.2513996,-30.289104 8.7239291,-25.102689 2.9039385,-29.079505 C 3.8696964,-30.204894 5.3011577,-30.634458 7.2513996,-30.289104 Z" />
            <path class="toRaise" d="M -7.2944895,-30.242785 -8.7622788,-25.054926 -2.9459251,-29.037457 C -3.9127109,-30.161897 -5.344564,-30.590055 -7.2944895,-30.242785 Z" />
        </g>
    </svg>

    <svg viewBox="-118 -145.7 236 146"
         id="layingTemplate4"
         class="layingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignStartpoint" d="M -11.0661,-32.409 C -7.6057,-40.358 -12.9836,-45.942 -22.6449,-45.942 -48.0054,-45.942 -53.754,-25.903 -47.9624,-23.154 -48.3022,-19.913 -48.0365,-16.799 -47.3256,-14.176 -46.087,-9.607 -43.7877,-6.071 -40.9347,-3.386 -41.3684,-1.151 -39.3743,-0.031 -38.2627,0 H 0 L -0.0027,-35.717" />
            <path class="toSquish alignStartpoint" d="M 11.0661,-32.409 C 7.6057,-40.358 12.9836,-45.942 22.6449,-45.942 48.0054,-45.942 53.754,-25.903 47.9624,-23.154 48.3022,-19.913 48.0365,-16.799 47.3256,-14.176 46.087,-9.607 43.7877,-6.071 40.9347,-3.386 41.3684,-1.151 39.3743,-0.031 38.2627,0 H 0 L 0.0027,-35.717" />
            <path class="toRaise" d="M -3.3546,-38.244 C -3.3546,-38.244 0.2841,-32.407 3.1354,-38.465 3.1354,-38.465 19.7926,-59.387 19.7447,-70.27 19.7398,-81.154 8.5599,-90.209 -5.8274,-89.64 -20.2148,-89.068 -30.7814,-67.348 -30.7814,-67.348 -30.7814,-67.348 -8.3952,-81.342 2.2893,-66.696 12.9738,-52.047 -3.3546,-38.25 -3.3546,-38.25 Z" />
            <path class="toRaise" d="M 11.0661,-32.409 C 18.6243,-34.892 21.6898,-34.255 21.6879,-38.349 21.686,-42.443 18.3358,-41.795 10.7694,-44.269 7.6235,-45.298 3.3593,-47.314 -0.0042,-47.313 -3.3666,-47.311 -7.63,-45.289 -10.7759,-44.256 -18.3371,-41.775 -21.69,-42.56 -21.6881,-38.328 -21.6861,-34.094 -18.6243,-34.883 -11.0609,-32.409" />
            <g style="fill: #338000" class="braColor">
                <path class="toSquish isLayingBra" d="M 0.019819,-45.861434 C 0.019819,-45.861434 -46.774825,-12.405074 -47.962334,-23.155124 -48.302176,-19.914193 -48.036393,-16.799732 -47.325487,-14.176531 -46.086799,-9.6072213 -43.787643,-6.0720505 -40.934644,-3.3869038 -46.774825,-12.405074 0.019819,-45.861434 0.019819,-45.861434 Z" />
                <path class="toSquish" d="M -47.325487,-14.176531 C -47.656297,-12.403353 -47.143395,-11.057768 -45.919071,-10.298081" />
                <path class="toSquish isLayingBra" d="M 0.02598,-45.861434 C 0.02598,-45.861434 46.775725,-12.405074 47.963234,-23.155124 48.303076,-19.914193 48.037293,-16.799732 47.326387,-14.176531 46.087699,-9.6072213 43.788543,-6.0720505 40.935544,-3.3869038 46.775725,-12.405074 0.02598,-45.861434 0.02598,-45.861434 Z" />
                <path class="toSquish" d="M 47.326387,-14.176531 C 47.657197,-12.403353 47.144295,-11.057768 45.919971,-10.298081" />
            </g>
            <path class="toRaise" d="M 8.339014,-40.535284 C 8.187493,-36.634827 6.623586,-35.815254 5.250042,-34.309921 3.942971,-32.877399 3.776763,-31.202847 3.484746,-29.117373 3.330571,-28.016385 2.417449,-25.350448 1.313626,-25.349905 L 0.002745,-25.349261 -1.308136,-25.348618 C -2.41195,-25.348075 -3.327517,-28.013114 -3.482698,-29.113951 -3.776586,-31.199137 -3.944324,-32.873525 -5.252729,-34.304763 -6.627648,-35.808745 -8.192295,-36.626781 -8.347388,-40.527088 -8.502473,-44.427309 -4.613458,-48.852156 -0.007994,-48.854419 4.597478,-48.856681 8.490552,-44.435656 8.339014,-40.535284 Z" />
            <path class="toRaise" d="M 7.2494,-39.941304 8.721929,-34.754889 2.901939,-38.731705 C 3.867696,-39.857094 5.299158,-40.286658 7.2494,-39.941304 Z" />
            <path class="toRaise" d="M -7.29649,-39.894985 -8.764279,-34.707126 -2.947925,-38.689657 C -3.914711,-39.814097 -5.346564,-40.242255 -7.29649,-39.894985 Z" />
        </g>
    </svg>

    <svg viewBox="-118 -145.7 236 146"
         id="layingTemplate5"
         class="layingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignStartpoint" d="M -11.0602,-42.854 C -6.4527,-53.435 -19.2518,-60.447 -30.1519,-60.454 -60.5979,-60.472 -71.5739,-34.482 -63.8624,-30.823 -64.3148,-26.508 -63.961,-22.362 -63.0143,-18.871 -61.3651,-12.788 -58.3037,-8.082 -54.5049,-4.508 -55.0824,-1.533 -52.4272,-0.041 -50.9471,0 H 0 L -0.0036,-47.546" />
            <path class="toSquish alignStartpoint" d="M 11.0667,-42.854 C 6.4591,-53.435 19.2517,-60.447 30.1519,-60.454 60.5978,-60.472 71.5738,-34.482 63.8622,-30.823 64.3147,-26.508 63.961,-22.362 63.0143,-18.871 61.3651,-12.788 58.3036,-8.082 54.5049,-4.508 55.0822,-1.533 52.4272,-0.041 50.947,0 H 0 L 0.0035,-47.546" />
            <path class="toRaise" d="M -3.3539,-48.689 C -3.3539,-48.689 0.2848,-42.852 3.1361,-48.91 3.1361,-48.91 19.7933,-69.832 19.7454,-80.715 19.7405,-91.599 8.5606,-100.654 -5.8267,-100.085 -20.2141,-99.513 -30.7807,-77.793 -30.7807,-77.793 -30.7807,-77.793 -8.3945,-91.787 2.29,-77.141 12.9745,-62.492 -3.3539,-48.695 -3.3539,-48.695 Z" />
            <path class="toRaise" d="M 11.0668,-42.854 C 18.625,-45.337 21.6905,-44.7 21.6886,-48.794 21.6867,-52.888 18.3365,-52.24 10.7701,-54.714 7.6242,-55.743 3.36,-57.759 -0.0035,-57.758 -3.3659,-57.756 -7.6293,-55.734 -10.7752,-54.701 -18.3364,-52.22 -21.6893,-53.005 -21.6874,-48.773 -21.6854,-44.539 -18.6236,-45.328 -11.0602,-42.854" />
            <g style="fill: #ffdd55" class="braColor">
                <path class="toSquish isLayingBra" d="M -0.003683,-57.757788 C -0.003683,-57.757788 -62.28137,-16.512671 -63.86255,-30.822996 -64.31505,-26.508711 -63.96116,-22.362783 -63.01458,-18.870811 -61.36526,-12.788207 -58.30391,-8.082235 -54.50512,-4.5078033 -62.28137,-16.512671 -0.003683,-57.757788 -0.003683,-57.757788 Z" />
                <path class="toSquish" d="M -63.01458,-18.870811 C -63.45506,-16.510381 -62.77212,-14.719156 -61.14193,-13.707871" />
                <path class="toSquish isLayingBra" d="M 0.004612,-57.757788 C 0.004612,-57.757788 62.28207,-16.512671 63.863249,-30.822996 64.315751,-26.508711 63.961858,-22.362783 63.01528,-18.870811 61.365957,-12.788207 58.304612,-8.082235 54.50582,-4.5078033 62.28207,-16.512671 0.004612,-57.757788 0.004612,-57.757788 Z" />
                <path class="toSquish" d="M 63.01528,-18.870811 C 63.455757,-16.510381 62.772824,-14.719156 61.142626,-13.707871" />
            </g>
            <path class="toRaise" d="M 8.339714,-50.979684 C 8.188193,-47.079227 6.624286,-46.259654 5.250742,-44.754321 3.943671,-43.321799 3.777463,-41.647247 3.485446,-39.561773 3.331271,-38.460785 2.418149,-35.794848 1.314326,-35.794305 L 0.003445,-35.793661 -1.307436,-35.793018 C -2.41125,-35.792475 -3.326817,-38.457514 -3.481998,-39.558351 -3.775886,-41.643537 -3.943624,-43.317925 -5.252029,-44.749163 -6.626948,-46.253145 -8.191595,-47.071181 -8.346688,-50.971488 -8.501773,-54.871709 -4.612758,-59.296556 -0.007294,-59.298819 4.598178,-59.301081 8.491252,-54.880056 8.339714,-50.979684 Z" />
            <path class="toRaise" d="M 7.2501,-50.385704 8.722629,-45.199289 2.902639,-49.176105 C 3.868396,-50.301494 5.299858,-50.731058 7.2501,-50.385704 Z" />
            <path class="toRaise" d="M -7.29579,-50.339385 -8.763579,-45.151526 -2.947225,-49.134057 C -3.914011,-50.258497 -5.345864,-50.686655 -7.29579,-50.339385 Z" />
        </g>
    </svg>


    <svg viewBox="-118 -145.7 236 146"
         id="layingTemplate6"
         class="layingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignStartpoint" d="M -11.0521,-64.457 C -16.4356,-74.4 -25.2962,-79.425 -39.6186,-79.434 -79.6236,-79.459 -94.0455,-45.309 -83.9128,-40.501 -84.5074,-34.832 -84.0426,-29.384 -82.7986,-24.797 -80.6317,-16.804 -76.6089,-10.62 -71.6177,-5.924 -72.3763,-2.013 -68.8876,-0.055 -66.9426,0 H 0 L -0.0046,-67.766" />
            <path class="toSquish alignStartpoint" d="M 11.075,-64.457 C 16.4585,-74.4 25.2961,-79.425 39.6185,-79.434 79.6233,-79.459 94.0455,-45.309 83.9127,-40.501 84.5073,-34.832 84.0424,-29.384 82.7986,-24.797 80.6314,-16.804 76.6089,-10.62 71.6174,-5.924 72.3762,-2.013 68.8875,-0.055 66.9425,0 H 0 L 0.0046,-67.766" />
            <path class="toRaise" d="M -3.3457,-70.292 C -3.3457,-70.292 0.293,-64.455 3.1443,-70.513 3.1443,-70.513 19.8015,-91.435 19.7536,-102.318 19.7487,-113.202 8.5688,-122.257 -5.8185,-121.688 -20.2059,-121.116 -30.7725,-99.396 -30.7725,-99.396 -30.7725,-99.396 -8.3863,-113.39 2.2982,-98.744 12.9827,-84.095 -3.3457,-70.298 -3.3457,-70.298 Z" />
            <path class="toRaise" d="M 11.075,-64.457 C 18.6332,-66.94 21.6987,-66.303 21.6968,-70.397 21.6949,-74.491 18.3447,-73.843 10.7783,-76.317 7.6324,-77.346 3.3682,-79.362 0.0047,-79.361 -3.3577,-79.359 -7.6211,-77.337 -10.767,-76.304 -18.3282,-73.823 -21.6811,-74.608 -21.6792,-70.376 -21.6772,-66.142 -18.6154,-66.931 -11.052,-64.457" />
            <g style="fill: #ff9955" class="braColor">
                <path class="toSquish isLayingBra" d="M 0.007984,-77.802204 C 0.007984,-77.802204 -81.8352,-21.696356 -83.91277,-40.500286 -84.5074,-34.832022 -84.04238,-29.383378 -82.79857,-24.796193 -80.63147,-16.803583 -76.60889,-10.61933 -71.61739,-5.923311 -81.83516,-21.696356 0.007984,-77.802204 0.007984,-77.802204 Z" />
                <path class="toSquish" d="M -82.79862,-24.796193 C -83.37732,-21.694229 -82.47993,-19.340813 -80.33802,-18.010868" />
                <path class="toSquish isLayingBra" d="M 0.007984,-77.802204 C 0.007984,-77.802204 81.835203,-21.696356 83.912771,-40.500286 84.507401,-34.832022 84.042388,-29.383378 82.798572,-24.796193 80.63147,-16.803583 76.608895,-10.61933 71.6174,-5.923311 81.835167,-21.696356 0.007984,-77.802204 0.007984,-77.802204 Z" />
                <path class="toSquish" d="M 82.798625,-24.796193 C 83.377327,-21.694229 82.479938,-19.340813 80.338022,-18.010868" />
            </g>
            <path class="toRaise" d="M 8.347814,-72.582084 C 8.196293,-68.681627 6.632386,-67.862054 5.258842,-66.356721 3.951771,-64.924199 3.785563,-63.249647 3.493546,-61.164173 3.339371,-60.063185 2.426249,-57.397248 1.322426,-57.396705 L 0.011545,-57.396061 -1.299336,-57.395418 C -2.40315,-57.394875 -3.318717,-60.059914 -3.473898,-61.160751 -3.767786,-63.245937 -3.935524,-64.920325 -5.243929,-66.351563 -6.618848,-67.855545 -8.183495,-68.673581 -8.338588,-72.573888 -8.493673,-76.474109 -4.604658,-80.89896 8.06e-4,-80.90122 4.606278,-80.90348 8.499352,-76.482456 8.347814,-72.582084 Z" />
            <path class="toRaise" d="M 7.2582,-71.988104 8.730729,-66.801689 2.910739,-70.778505 C 3.876496,-71.903894 5.307958,-72.333458 7.2582,-71.988104 Z" />
            <path class="toRaise" d="M -7.28769,-71.941785 -8.755479,-66.753926 -2.939125,-70.736457 C -3.905911,-71.860897 -5.337764,-72.289055 -7.28769,-71.941785 Z" />
        </g>
    </svg>

    <svg viewBox="-118 -145.7 236 146"
         id="layingTemplate7"
         class="layingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignStartpoint" d="M -11.0567,-91.467002 C -27.03359,-138.09311 -118.36698,-127.7855 -120.011,-91.877772 V -2e-6 H -91.484644 -0.01099 L 0,-106.371" />
            <path class="toSquish alignStartpoint" d="M 11.04571,-91.467002 C 27.0226,-138.09311 118.35599,-127.7855 120.00001,-91.877772 V 0 H 91.473648 0 L -0.01099,-106.371" />
            <path class="toRaise" d="M -3.3504,-97.302002 C -3.3504,-97.302002 0.2883,-91.465002 3.1395997,-97.523002 3.1395997,-97.523002 19.7968,-118.445 19.7489,-129.328 19.744,-140.212 8.5640997,-149.267 -5.8232,-148.698 -20.2106,-148.126 -30.7772,-126.406 -30.7772,-126.406 -30.7772,-126.406 -8.391,-140.4 2.2934997,-125.754 12.978,-111.105 -3.3504,-97.308002 -3.3504,-97.308002 Z" />
            <path class="toRaise" d="M 11.0703,-91.467002 C 18.6285,-93.950002 21.694,-93.313002 21.6921,-97.407002 21.6902,-101.501 18.34,-100.853 10.7736,-103.327 7.6276997,-104.356 3.3634997,-106.372 0,-106.371 -3.3624,-106.369 -7.6258,-104.347 -10.7717,-103.314 -18.3329,-100.833 -21.6858,-101.618 -21.6839,-97.386002 -21.6819,-93.152002 -18.6201,-93.941002 -11.0567,-91.467002" />
            <g style="fill: #000000" class="braColor">
                <path class="toSquish isLayingBra" d="M -0.01099,-106.371 C -0.01099,-106.371 -120.011,-45.93889 -120.011,-75 V -22.98647 C -120.011,-45.93889 -0.01099,-106.371 -0.01099,-106.371 Z" />
                <path class="toSquish isLayingBra" d="M -0.01099,-106.371 C -0.01099,-106.371 119.98903,-45.93889 119.98903,-75 V -22.98648 C 119.98903,-45.93889 -0.01099,-106.371 -0.01099,-106.371 Z" />
            </g>
            <path class="toRaise" d="M 8.3431139,-99.592382 C 8.1915931,-95.691922 6.6276855,-94.872352 5.2541419,-93.367022 3.9470709,-91.934502 3.7808622,-90.259942 3.4888459,-88.174472 3.3346704,-87.073482 2.4215484,-84.407552 1.3177253,-84.407002 L 0.006845,-84.406362 -1.304036,-84.405722 C -2.407851,-84.405172 -3.323417,-87.070212 -3.478598,-88.171052 -3.772486,-90.256232 -3.940225,-91.930622 -5.24863,-93.361862 -6.623548,-94.865842 -8.188195,-95.683882 -8.343289,-99.584192 -8.498374,-103.48441 -4.609358,-107.90926 -0.003894,-107.91152 4.6015777,-107.91378 8.4946519,-103.49276 8.3431139,-99.592382 Z" />
            <path class="toRaise" d="M 7.2534993,-98.998402 8.7260284,-93.811992 2.9060382,-97.788802 C 3.8717961,-98.914192 5.3032574,-99.343762 7.2534993,-98.998402 Z" />
            <path class="toRaise" d="M -7.29239,-98.952082 -8.760179,-93.764222 -2.943825,-97.746752 C -3.910611,-98.871192 -5.342464,-99.299352 -7.29239,-98.952082 Z" />
            <g style="opacity:0.1;fill: #000000;">
                <path class="toSquish" d="M -110.56924,-88.072722 C -110.56924,-61.949609 -110.56924,-41.797817 -110.56924,-29.948619 -110.56924,-15.120006 -102.72713,-8.272691 -86.6134,-8.272691 L -30.26137,-8.272691 C -12.33782,-8.272691 -12.33781,-21.892605 -12.33781,-64.410062 -12.33781,-124.26462 -110.56924,-128.07863 -110.56924,-88.072722 Z" />
                <path class="toSquish" d="M 110.55825,-88.072722 C 110.55825,-61.949609 110.55825,-41.797812 110.55825,-29.948614 110.55825,-15.120001 102.71614,-8.272686 86.602408,-8.272686 L 30.25038,-8.272686 C 12.32683,-8.272686 12.32682,-21.8926 12.32682,-64.410052 12.32682,-124.26462 110.55825,-128.07863 110.55825,-88.072722 Z" />
            </g>
        </g>
    </svg>

    <svg viewBox="-118 -145.7 236 146"
         id="layingTemplate8"
         class="layingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignStartpoint" d="M -11.0521,-64.457 C -16.4356,-74.4 -25.2962,-79.425 -39.6186,-79.434 -79.6236,-79.459 -94.0455,-45.309 -83.9128,-40.501 -84.5074,-34.832 -84.0426,-29.384 -82.7986,-24.797 -80.6317,-16.804 -76.6089,-10.62 -71.6177,-5.924 -72.3763,-2.013 -68.8876,-0.055 -66.9426,0 H 0 L -0.0046,-67.766" />
            <path class="toSquish alignStartpoint" d="M 11.075,-64.457 C 16.4585,-74.4 25.2961,-79.425 39.6185,-79.434 79.6233,-79.459 94.0455,-45.309 83.9127,-40.501 84.5073,-34.832 84.0424,-29.384 82.7986,-24.797 80.6314,-16.804 76.6089,-10.62 71.6174,-5.924 72.3762,-2.013 68.8875,-0.055 66.9425,0 H 0 L 0.0046,-67.766" />
            <g style="opacity:1;">
                <path class="toRaise" d="M -3.3457,-70.292 C -3.3457,-70.292 0.293,-64.455 3.1443,-70.513 3.1443,-70.513 19.8015,-91.435 19.7536,-102.318 19.7487,-113.202 8.5688,-122.257 -5.8185,-121.688 -20.2059,-121.116 -30.7725,-99.396 -30.7725,-99.396 -30.7725,-99.396 -8.3863,-113.39 2.2982,-98.744 12.9827,-84.095 -3.3457,-70.298 -3.3457,-70.298 Z" />
                <path class="toRaise" d="M 11.075,-64.457 C 18.6332,-66.94 21.6987,-66.303 21.6968,-70.397 21.6949,-74.491 18.3447,-73.843 10.7783,-76.317 7.6324,-77.346 3.3682,-79.362 0.0047,-79.361 -3.3577,-79.359 -7.6211,-77.337 -10.767,-76.304 -18.3282,-73.823 -21.6811,-74.608 -21.6792,-70.376 -21.6772,-66.142 -18.6154,-66.931 -11.052,-64.457" />
            </g>
            <g style="fill: #ff9955" class="braColor">
                <path class="toSquish isLayingBra" d="M 0.007984,-77.802204 C 0.007984,-77.802204 -81.8352,-21.696356 -83.91277,-40.500286 -84.5074,-34.832022 -84.04238,-29.383378 -82.79857,-24.796193 -80.63147,-16.803583 -76.60889,-10.61933 -71.61739,-5.923311 -81.83516,-21.696356 0.007984,-77.802204 0.007984,-77.802204 Z" />
                <path class="toSquish" d="M -82.79862,-24.796193 C -83.37732,-21.694229 -82.47993,-19.340813 -80.33802,-18.010868" />
                <path class="toSquish isLayingBra" d="M 0.007984,-77.802204 C 0.007984,-77.802204 81.835203,-21.696356 83.912771,-40.500286 84.507401,-34.832022 84.042388,-29.383378 82.798572,-24.796193 80.63147,-16.803583 76.608895,-10.61933 71.6174,-5.923311 81.835167,-21.696356 0.007984,-77.802204 0.007984,-77.802204 Z" />
                <path class="toSquish" d="M 82.798625,-24.796193 C 83.377327,-21.694229 82.479938,-19.340813 80.338022,-18.010868" />
            </g>
            <g style="opacity:1;">
                <path class="toRaise" d="M 8.347814,-72.582084 C 8.196293,-68.681627 6.632386,-67.862054 5.258842,-66.356721 3.951771,-64.924199 3.785563,-63.249647 3.493546,-61.164173 3.339371,-60.063185 2.426249,-57.397248 1.322426,-57.396705 L 0.011545,-57.396061 -1.299336,-57.395418 C -2.40315,-57.394875 -3.318717,-60.059914 -3.473898,-61.160751 -3.767786,-63.245937 -3.935524,-64.920325 -5.243929,-66.351563 -6.618848,-67.855545 -8.183495,-68.673581 -8.338588,-72.573888 -8.493673,-76.474109 -4.604658,-80.89896 8.06e-4,-80.90122 4.606278,-80.90348 8.499352,-76.482456 8.347814,-72.582084 Z" />
                <path class="toRaise" d="M 7.2582,-71.988104 8.730729,-66.801689 2.910739,-70.778505 C 3.876496,-71.903894 5.307958,-72.333458 7.2582,-71.988104 Z" />
                <path class="toRaise" d="M -7.28769,-71.941785 -8.755479,-66.753926 -2.939125,-70.736457 C -3.905911,-71.860897 -5.337764,-72.289055 -7.28769,-71.941785 Z" />
            </g>
        </g>
    </svg>

    <svg viewBox="-118 -145.7 236 146"
         id="layingTemplateTemplate"
         class="layingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignStartpoint" d="" />
            <path class="toSquish alignStartpoint" d="" />
            <path class="toRaise" d="" />
            <path class="toRaise" d="" />
            <g style="fill: #ff5555" class="braColor">
                <path class="toSquish isLayingBra" d="" />
                <path class="toSquish" d="" />
                <path class="toSquish isLayingBra" d="" />
                <path class="toSquish" d="" />
            </g>
            <path class="toRaise" d="" />
            <path class="toRaise" d="" />
            <path class="toRaise" d="" />
            <path class="toSquish" d="M 110.55825,-88.072722 L 110.55825,-61.949609 110.55825,-41.797812 110.55825,-29.948614 110.55825,-15.120001 102.71614,-8.272686 86.602408,-8.272686 H 30.25038 L 12.32683,-8.272686 12.32682,-21.8926 12.32682,-64.410052 12.32682,-124.26462 110.55825,-128.07863 110.55825,-88.072722 Z" />
        </g>
    </svg>

    <svg viewBox="-500 -500 1000 1000"
         id="hangingTemplate1"
         class="hangingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignEndpoint" d="M 0,0 0.0,28.528887 C -1.602113,32.473887 -11.707413,31.788887 -12.320213,29.501887 -16.051513,26.412887 -16.051513,26.412887 -17.937313,21.677887 -20.160113,20.316887 -18.245413,10.047887 -11.056613,8.1218865" />
            <path class="toSquish alignEndpoint" d="M 0,0 0.0,28.528887 C 1.615687,32.473887 11.720987,31.788888 12.333787,29.501888 16.065087,26.412887 16.065087,26.412887 17.950887,21.677887 20.173687,20.316887 18.258987,10.047887 11.070187,8.1218865" />
            <path class="" d="M -3.350513,2.2868864 C -3.350513,2.2868864 0.288187,8.1238866 3.139487,2.0658864 3.139487,2.0658864 19.796687,-18.856113 19.748787,-29.740113 19.743887,-40.623113 8.563987,-49.678113 -5.823313,-49.110113 -20.210713,-48.538113 -30.777313,-26.817113 -30.777313,-26.817113 -30.777313,-26.817113 -8.391113,-40.811113 2.293387,-26.166113 12.977887,-11.517114 -3.350513,2.2808864 -3.350513,2.2808864 Z" />
            <path class="" d="M 11.070187,8.1218865 C 18.628387,5.6388865 21.693887,6.2758865 21.691987,2.1808864 21.690087,-1.9131136 18.339887,-1.2641136 10.773487,-3.7381136 7.627587,-4.7671136 3.363387,-6.7841136 -1.13e-4,-6.7821136 -3.362513,-6.7801136 -7.625913,-4.7591136 -10.771813,-3.7261136 -18.333013,-1.2441136 -21.685913,-2.0301136 -21.684013,2.2028864 -21.682013,6.4358865 -18.620213,5.6468865 -11.056813,8.1218865" />
            <g style="fill: #ff5555" class="braColor">
                <path class="toSquish isHangingBra" d="M -12.320213,29.501887 C -13.892613,28.746887 -15.347313,27.554887 -16.488413,25.781887 -17.190613,24.690887 -17.688813,23.258887 -17.937313,21.677887 -16.012313,26.464887 -1.3e-5,-6.7821136 -1.3e-5,-6.7821136 -1.3e-5,-6.7821136 -16.012313,26.464887 -12.320213,29.501887 Z" />
                <path class="toSquish" d="M -16.880613,25.096887 C -16.989913,26.134887 -16.658713,26.747887 -15.583313,26.997887" />
                <path class="toSquish isHangingBra" d="M 12.333187,29.501887 C 13.905587,28.746887 15.360287,27.554887 16.501387,25.781887 17.203587,24.690887 17.701787,23.258887 17.950287,21.677887 16.025287,26.464887 0.012987,-6.7821136 0.012987,-6.7821136 0.012987,-6.7821136 16.025287,26.464887 12.333187,29.501887 Z" />
                <path class="toSquish" d="M 16.893587,25.096887 C 17.002887,26.134887 16.671687,26.747887 15.596287,26.997887" />
            </g>
            <path class="" d="M 8.343201,-0.00409795 C 8.19168,3.8963595 6.627773,4.7159325 5.254229,6.2212655 3.947158,7.6537875 3.78095,9.3283395 3.488933,11.413814 3.334758,12.514802 2.421636,15.180739 1.317813,15.181282 L 0.006932,15.181926 -1.303949,15.182569 C -2.407763,15.183112 -3.32333,12.518073 -3.478511,11.417236 -3.772399,9.3320495 -3.940137,7.6576615 -5.248542,6.2264235 -6.623461,4.7224415 -8.188108,3.9044054 -8.343201,0.00409825 -8.498286,-3.8961228 -4.609271,-8.32097 -0.003807,-8.3232322 4.601665,-8.3254944 8.494739,-3.9044696 8.343201,-0.00409795 Z" />
            <path class="" d="M 7.253587,0.58988245 8.726116,5.7762975 2.906126,1.7994814 C 3.871883,0.67409265 5.303345,0.24452835 7.253587,0.58988245 Z" />
            <path class="" d="M -7.292303,0.63620175 -8.760092,5.8240605 -2.943738,1.8415294 C -3.910524,0.71708975 -5.342377,0.28893185 -7.292303,0.63620175 Z" />
        </g>
    </svg>

    <svg viewBox="-500 -500 1000 1000"
         id="hangingTemplate2"
         class="hangingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignEndpoint" d="M 0,0 0.0069865,38.030784 C -2.3511135,43.812784 -17.161113,42.808785 -18.059214,39.456784 -23.527714,34.929784 -23.527714,34.929784 -26.291513,27.990784 -29.549114,25.995784 -27.472113,8.5917845 -11.056714,8.1217845" />
            <path class="toSquish alignEndpoint" d="M 0,0 0.0069865,38.030784 C 2.3650865,43.812784 17.175086,42.808785 18.073186,39.456784 23.541686,34.929784 23.541686,34.929784 26.305486,27.990784 29.563086,25.995784 27.486086,8.5917845 11.070686,8.1217845" />
            <path class="" d="M -3.350513,2.2868864 C -3.350513,2.2868864 0.288187,8.1238866 3.139487,2.0658864 3.139487,2.0658864 19.796687,-18.856113 19.748787,-29.740113 19.743887,-40.623113 8.563987,-49.678113 -5.823313,-49.110113 -20.210713,-48.538113 -30.777313,-26.817113 -30.777313,-26.817113 -30.777313,-26.817113 -8.391113,-40.811113 2.293387,-26.166113 12.977887,-11.517114 -3.350513,2.2808864 -3.350513,2.2808864 Z" />
            <path class="" d="M 11.070187,8.1218865 C 18.628387,5.6388865 21.693887,6.2758865 21.691987,2.1808864 21.690087,-1.9131136 18.339887,-1.2641136 10.773487,-3.7381136 7.627587,-4.7671136 3.363387,-6.7841136 -1.13e-4,-6.7821136 -3.362513,-6.7801136 -7.625913,-4.7591136 -10.771813,-3.7261136 -18.333013,-1.2441136 -21.685913,-2.0301136 -21.684013,2.2028864 -21.682013,6.4358865 -18.620213,5.6468865 -11.056813,8.1218865" />
            <g style="fill: #9955ff" class="braColor">
                <path class="toSquish isHangingBra" d="M -18.059308,39.457122 C -20.363768,38.350618 -22.49573,36.60366 -24.168091,34.005206 -25.197214,32.40627 -25.92736,30.307576 -26.291553,27.990511 -23.470334,35.006189 -1.285e-4,-6.7830395 -1.285e-4,-6.7830395 -1.285e-4,-6.7830395 -23.470334,35.006189 -18.059308,39.457122 Z" />
                <path class="toSquish" d="M -24.742888,33.001291 C -24.903074,34.522553 -24.417678,35.420946 -22.841605,35.787337" />
                <path class="toSquish isHangingBra" d="M 18.07378,39.457122 C 20.37824,38.350618 22.510203,36.60366 24.182564,34.005206 25.211686,32.40627 25.941833,30.307576 26.306027,27.990511 23.484807,35.006189 0.0146015,-6.7830395 0.0146015,-6.7830395 0.0146015,-6.7830395 23.484807,35.006189 18.07378,39.457122 Z" />
                <path class="toSquish" d="M 24.75736,33.001291 C 24.917547,34.522553 24.43215,35.420946 22.856078,35.787337" />
            </g>
            <path class="" d="M 8.343201,-0.00409795 C 8.19168,3.8963595 6.627773,4.7159325 5.254229,6.2212655 3.947158,7.6537875 3.78095,9.3283395 3.488933,11.413814 3.334758,12.514802 2.421636,15.180739 1.317813,15.181282 L 0.006932,15.181926 -1.303949,15.182569 C -2.407763,15.183112 -3.32333,12.518073 -3.478511,11.417236 -3.772399,9.3320495 -3.940137,7.6576615 -5.248542,6.2264235 -6.623461,4.7224415 -8.188108,3.9044054 -8.343201,0.00409825 -8.498286,-3.8961228 -4.609271,-8.32097 -0.003807,-8.3232322 4.601665,-8.3254944 8.494739,-3.9044696 8.343201,-0.00409795 Z" />
            <path class="" d="M 7.253587,0.58988245 8.726116,5.7762975 2.906126,1.7994814 C 3.871883,0.67409265 5.303345,0.24452835 7.253587,0.58988245 Z" />
            <path class="" d="M -7.292303,0.63620175 -8.760092,5.8240605 -2.943738,1.8415294 C -3.910524,0.71708975 -5.342377,0.28893185 -7.292303,0.63620175 Z" />
        </g>
    </svg>

    <svg viewBox="-500 -500 1000 1000"
         id="hangingTemplate3"
         class="hangingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignEndpoint" d="M 0,0 0.0071,48.341817 C 3.17812,56.117076 23.09365,54.766962 24.301356,50.259409 31.655041,44.171792 31.655041,44.171792 35.371621,34.840674 39.752231,32.157927 39.632952,8.939728 11.071044,8.122128" />
            <path class="toSquish alignEndpoint" d="M 0,0 0.0071,48.341817 C -3.163921,56.117076 -23.079451,54.766962 -24.287157,50.259409 -31.640842,44.171792 -31.640842,44.171792 -35.357422,34.840674 -39.738031,32.157927 -39.618753,8.939728 -11.056845,8.122128" />
            <path class="" d="M -3.350513,2.2868864 C -3.350513,2.2868864 0.288187,8.1238866 3.139487,2.0658864 3.139487,2.0658864 19.796687,-18.856113 19.748787,-29.740113 19.743887,-40.623113 8.563987,-49.678113 -5.823313,-49.110113 -20.210713,-48.538113 -30.777313,-26.817113 -30.777313,-26.817113 -30.777313,-26.817113 -8.391113,-40.811113 2.293387,-26.166113 12.977887,-11.517114 -3.350513,2.2808864 -3.350513,2.2808864 Z" />
            <path class="" d="M 11.070187,8.1218865 C 18.628387,5.6388865 21.693887,6.2758865 21.691987,2.1808864 21.690087,-1.9131136 18.339887,-1.2641136 10.773487,-3.7381136 7.627587,-4.7671136 3.363387,-6.7841136 -1.13e-4,-6.7821136 -3.362513,-6.7801136 -7.625913,-4.7591136 -10.771813,-3.7261136 -18.333013,-1.2441136 -21.685913,-2.0301136 -21.684013,2.2028864 -21.682013,6.4358865 -18.620213,5.6468865 -11.056813,8.1218865" />
            <g style="fill: #3771c8" class="braColor">
                <path class="toSquish isHangingBra" d="M -24.28694,50.259113 C -27.385829,48.771158 -30.252755,46.421962 -32.501637,42.927729 -33.885535,40.777584 -34.867388,37.955396 -35.357132,34.839558 -31.563338,44.273787 2.4e-4,-6.781812 2.4e-4,-6.781812 2.4e-4,-6.781812 -31.563338,44.273787 -24.28694,50.259113 Z" />
                <path class="toSquish" d="M -33.274586,41.57773 C -33.489995,43.623423 -32.837265,44.831524 -30.717864,45.324225" />
                <path class="toSquish isHangingBra" d="M 24.302312,50.259113 C 27.401201,48.771158 30.268127,46.421962 32.517009,42.927729 33.900907,40.777584 34.88276,37.955396 35.372504,34.839558 31.57871,44.273787 0.019862,-6.781812 0.019862,-6.781812 0.019862,-6.781812 31.57871,44.273787 24.302312,50.259113 Z" />
                <path class="toSquish" d="M 33.289958,41.57773 C 33.505367,43.623423 32.852637,44.831524 30.733236,45.324225" />
            </g>
            <path class="" d="M 8.343201,-0.00409795 C 8.19168,3.8963595 6.627773,4.7159325 5.254229,6.2212655 3.947158,7.6537875 3.78095,9.3283395 3.488933,11.413814 3.334758,12.514802 2.421636,15.180739 1.317813,15.181282 L 0.006932,15.181926 -1.303949,15.182569 C -2.407763,15.183112 -3.32333,12.518073 -3.478511,11.417236 -3.772399,9.3320495 -3.940137,7.6576615 -5.248542,6.2264235 -6.623461,4.7224415 -8.188108,3.9044054 -8.343201,0.00409825 -8.498286,-3.8961228 -4.609271,-8.32097 -0.003807,-8.3232322 4.601665,-8.3254944 8.494739,-3.9044696 8.343201,-0.00409795 Z" />
            <path class="" d="M 7.253587,0.58988245 8.726116,5.7762975 2.906126,1.7994814 C 3.871883,0.67409265 5.303345,0.24452835 7.253587,0.58988245 Z" />
            <path class="" d="M -7.292303,0.63620175 -8.760092,5.8240605 -2.943738,1.8415294 C -3.910524,0.71708975 -5.342377,0.28893185 -7.292303,0.63620175 Z" />
        </g>
    </svg>

    <svg viewBox="-500 -500 1000 1000"
         id="hangingTemplate4"
         class="hangingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignEndpoint" d="M 0,0 0.007063,60.516691 C -4.123918,70.645747 -30.06846,68.886915 -31.641775,63.014795 -41.221634,55.084279 -41.221634,55.084279 -46.063331,42.928359 -51.770074,39.433466 -52.845874,9.3178265 -11.056068,8.1213295" />
            <path class="toSquish alignEndpoint" d="M 0,0 0.007063,60.516691 C 4.138043,70.645747 30.082585,68.886915 31.6559,63.014795 41.23576,55.084279 41.23576,55.084279 46.077456,42.928359 51.784204,39.433466 52.86,9.3178265 11.070193,8.1213295" />
            <path class="" d="M -3.350513,2.2868864 C -3.350513,2.2868864 0.288187,8.1238866 3.139487,2.0658864 3.139487,2.0658864 19.796687,-18.856113 19.748787,-29.740113 19.743887,-40.623113 8.563987,-49.678113 -5.823313,-49.110113 -20.210713,-48.538113 -30.777313,-26.817113 -30.777313,-26.817113 -30.777313,-26.817113 -8.391113,-40.811113 2.293387,-26.166113 12.977887,-11.517114 -3.350513,2.2808864 -3.350513,2.2808864 Z" />
            <path class="" d="M 11.070187,8.1218865 C 18.628387,5.6388865 21.693887,6.2758865 21.691987,2.1808864 21.690087,-1.9131136 18.339887,-1.2641136 10.773487,-3.7381136 7.627587,-4.7671136 3.363387,-6.7841136 -1.13e-4,-6.7821136 -3.362513,-6.7801136 -7.625913,-4.7591136 -10.771813,-3.7261136 -18.333013,-1.2441136 -21.685913,-2.0301136 -21.684013,2.2028864 -21.682013,6.4358865 -18.620213,5.6468865 -11.056813,8.1218865" />
            <g style="fill: #338000" class="braColor">
                <path class="toSquish isHangingBra" d="M -31.642343,63.014557 C -35.679356,61.076153 -39.414184,58.015787 -42.343869,53.463749 -44.146712,50.662692 -45.425801,46.986145 -46.063805,42.927052 -41.121519,55.217297 -0.002725,-6.7833625 -0.002725,-6.7833625 -0.002725,-6.7833625 -41.121519,55.217297 -31.642343,63.014557 Z" />
                <path class="toSquish" d="M -43.350811,51.705065 C -43.63143,54.370049 -42.7811,55.943877 -40.020095,56.585733" />
                <path class="toSquish isHangingBra" d="M 31.657515,63.014557 C 35.694528,61.076153 39.429356,58.015787 42.359041,53.463749 44.161884,50.662692 45.440973,46.986145 46.078977,42.927052 41.136691,55.217297 0.024059,-6.7833625 0.024059,-6.7833625 0.024059,-6.7833625 41.136691,55.217297 31.657515,63.014557 Z" />
                <path class="toSquish" d="M 43.365983,51.705065 C 43.646602,54.370049 42.796272,55.943877 40.035267,56.585733" />
            </g>
            <path class="" d="M 8.343201,-0.00409795 C 8.19168,3.8963595 6.627773,4.7159325 5.254229,6.2212655 3.947158,7.6537875 3.78095,9.3283395 3.488933,11.413814 3.334758,12.514802 2.421636,15.180739 1.317813,15.181282 L 0.006932,15.181926 -1.303949,15.182569 C -2.407763,15.183112 -3.32333,12.518073 -3.478511,11.417236 -3.772399,9.3320495 -3.940137,7.6576615 -5.248542,6.2264235 -6.623461,4.7224415 -8.188108,3.9044054 -8.343201,0.00409825 -8.498286,-3.8961228 -4.609271,-8.32097 -0.003807,-8.3232322 4.601665,-8.3254944 8.494739,-3.9044696 8.343201,-0.00409795 Z" />
            <path class="" d="M 7.253587,0.58988245 8.726116,5.7762975 2.906126,1.7994814 C 3.871883,0.67409265 5.303345,0.24452835 7.253587,0.58988245 Z" />
            <path class="" d="M -7.292303,0.63620175 -8.760092,5.8240605 -2.943738,1.8415294 C -3.910524,0.71708975 -5.342377,0.28893185 -7.292303,0.63620175 Z" />
        </g>
    </svg>

    <svg viewBox="-500 -500 1000 1000"
         id="hangingTemplate5"
         class="hangingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignEndpoint" d="M 0,0 0.006697,78.523232 C -5.543937,92.133244 -40.404584,89.76997 -42.518584,81.879835 -55.390664,71.223916 -55.390664,71.223916 -61.896254,54.89049 -69.564184,50.194542 -67.208444,9.729355 -11.057145,8.12167" />
            <path class="toSquish alignEndpoint" d="M 0,0 0.006697,78.523232 C 5.557332,92.133244 40.417981,89.76997 42.531981,81.879835 55.404058,71.223916 55.404058,71.223916 61.909653,54.89049 69.577583,50.194542 67.221135,9.729355 11.069834,8.12167" />
            <path class="" d="M -3.350513,2.2868864 C -3.350513,2.2868864 0.288187,8.1238866 3.139487,2.0658864 3.139487,2.0658864 19.796687,-18.856113 19.748787,-29.740113 19.743887,-40.623113 8.563987,-49.678113 -5.823313,-49.110113 -20.210713,-48.538113 -30.777313,-26.817113 -30.777313,-26.817113 -30.777313,-26.817113 -8.391113,-40.811113 2.293387,-26.166113 12.977887,-11.517114 -3.350513,2.2808864 -3.350513,2.2808864 Z" />
            <path class="" d="M 11.070187,8.1218865 C 18.628387,5.6388865 21.693887,6.2758865 21.691987,2.1808864 21.690087,-1.9131136 18.339887,-1.2641136 10.773487,-3.7381136 7.627587,-4.7671136 3.363387,-6.7841136 -1.13e-4,-6.7821136 -3.362513,-6.7801136 -7.625913,-4.7591136 -10.771813,-3.7261136 -18.333013,-1.2441136 -21.685913,-2.0301136 -21.684013,2.2028864 -21.682013,6.4358865 -18.620213,5.6468865 -11.056813,8.1218865" />
            <g style="fill: #ffdd55" class="braColor">
                <path class="toSquish isHangingBra" d="M -42.518784,81.879654 C -47.943164,79.275099 -52.961504,75.163006 -56.898004,69.046614 -59.320414,65.282945 -61.039074,60.342914 -61.896334,54.888872 -55.255574,71.402787 -3.71e-4,-6.782165 -3.71e-4,-6.782165 -3.71e-4,-6.782165 -55.255574,71.402787 -42.518784,81.879654 Z" />
                <path class="toSquish" d="M -58.250994,66.68354 C -58.628044,70.264373 -57.485494,72.379064 -53.775644,73.2415" />
                <path class="toSquish isHangingBra" d="M 42.533958,81.880654 C 47.958333,79.276099 52.976672,75.164006 56.913173,69.047614 59.335582,65.283945 61.054243,60.343914 61.911504,54.889872 55.270751,71.403787 0.034862,-6.781165 0.034862,-6.781165 0.034862,-6.781165 55.270751,71.403787 42.533958,81.880654 Z" />
                <path class="toSquish" d="M 58.266162,66.68454 C 58.643219,70.265373 57.500664,72.380064 53.790812,73.2425" />
            </g>
            <path class="" d="M 8.343201,-0.00409795 C 8.19168,3.8963595 6.627773,4.7159325 5.254229,6.2212655 3.947158,7.6537875 3.78095,9.3283395 3.488933,11.413814 3.334758,12.514802 2.421636,15.180739 1.317813,15.181282 L 0.006932,15.181926 -1.303949,15.182569 C -2.407763,15.183112 -3.32333,12.518073 -3.478511,11.417236 -3.772399,9.3320495 -3.940137,7.6576615 -5.248542,6.2264235 -6.623461,4.7224415 -8.188108,3.9044054 -8.343201,0.00409825 -8.498286,-3.8961228 -4.609271,-8.32097 -0.003807,-8.3232322 4.601665,-8.3254944 8.494739,-3.9044696 8.343201,-0.00409795 Z" />
            <path class="" d="M 7.253587,0.58988245 8.726116,5.7762975 2.906126,1.7994814 C 3.871883,0.67409265 5.303345,0.24452835 7.253587,0.58988245 Z" />
            <path class="" d="M -7.292303,0.63620175 -8.760092,5.8240605 -2.943738,1.8415294 C -3.910524,0.71708975 -5.342377,0.28893185 -7.292303,0.63620175 Z" />
        </g>
    </svg>

    <svg viewBox="-500 -500 1000 1000"
         id="hangingTemplate6"
         class="hangingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignEndpoint" d="M 0.0077918,0 0.0077918,98.350373 C -7.1060552,115.79334 -51.784429,112.7645 -54.493791,102.65229 -70.991001,88.995367 -70.991001,88.995367 -79.328752,68.061995 -89.156183,62.043538 -86.547583,7.536525 -11.054706,8.121775" />
            <path class="toSquish alignEndpoint" d="M 0.0077918,0 0.0077918,98.350373 C 7.121639,115.79334 51.800013,112.7645 54.509375,102.65229 71.006586,88.995367 71.006586,88.995367 79.344336,68.061995 89.171769,62.043538 86.563167,7.536525 11.07029,8.121775" />
            <path class="" d="M -3.350513,2.2868864 C -3.350513,2.2868864 0.288187,8.1238866 3.139487,2.0658864 3.139487,2.0658864 19.796687,-18.856113 19.748787,-29.740113 19.743887,-40.623113 8.563987,-49.678113 -5.823313,-49.110113 -20.210713,-48.538113 -30.777313,-26.817113 -30.777313,-26.817113 -30.777313,-26.817113 -8.391113,-40.811113 2.293387,-26.166113 12.977887,-11.517114 -3.350513,2.2808864 -3.350513,2.2808864 Z" />
            <path class="" d="M 11.070187,8.1218865 C 18.628387,5.6388865 21.693887,6.2758865 21.691987,2.1808864 21.690087,-1.9131136 18.339887,-1.2641136 10.773487,-3.7381136 7.627587,-4.7671136 3.363387,-6.7841136 -1.13e-4,-6.7821136 -3.362513,-6.7801136 -7.625913,-4.7591136 -10.771813,-3.7261136 -18.333013,-1.2441136 -21.685913,-2.0301136 -21.684013,2.2028864 -21.682013,6.4358865 -18.620213,5.6468865 -11.056813,8.1218865" />
            <g style="fill: #ff9955" class="braColor">
                <path class="toSquish isHangingBra" d="M -54.493451,102.65263 C -61.445479,99.314555 -67.877122,94.044383 -72.922251,86.205445 -76.026877,81.381823 -78.229561,75.050543 -79.328251,68.060491 -70.817277,89.225183 6.55607e-4,-6.783021 6.55607e-4,-6.783021 6.55607e-4,-6.783021 -70.817277,89.225183 -54.493451,102.65263 Z" />
                <path class="toSquish" d="M -74.656279,83.176865 C -75.139525,87.766159 -73.675196,90.476406 -68.920546,91.581728" />
                <path class="toSquish isHangingBra" d="M 54.512451,102.65263 C 61.464479,99.314555 67.896122,94.044383 72.941251,86.205445 76.045877,81.381823 78.248561,75.050543 79.347251,68.060491 70.836277,89.225183 0.04575636,-6.783021 0.04575636,-6.783021 0.04575636,-6.783021 70.836277,89.225183 54.512451,102.65263 Z" />
                <path class="toSquish" d="M 74.675279,83.176865 C 75.158525,87.766159 73.694196,90.476406 68.939546,91.581728" />
            </g>
            <path class="" d="M 8.343201,-0.00409795 C 8.19168,3.8963595 6.627773,4.7159325 5.254229,6.2212655 3.947158,7.6537875 3.78095,9.3283395 3.488933,11.413814 3.334758,12.514802 2.421636,15.180739 1.317813,15.181282 L 0.006932,15.181926 -1.303949,15.182569 C -2.407763,15.183112 -3.32333,12.518073 -3.478511,11.417236 -3.772399,9.3320495 -3.940137,7.6576615 -5.248542,6.2264235 -6.623461,4.7224415 -8.188108,3.9044054 -8.343201,0.00409825 -8.498286,-3.8961228 -4.609271,-8.32097 -0.003807,-8.3232322 4.601665,-8.3254944 8.494739,-3.9044696 8.343201,-0.00409795 Z" />
            <path class="" d="M 7.253587,0.58988245 8.726116,5.7762975 2.906126,1.7994814 C 3.871883,0.67409265 5.303345,0.24452835 7.253587,0.58988245 Z" />
            <path class="" d="M -7.292303,0.63620175 -8.760092,5.8240605 -2.943738,1.8415294 C -3.910524,0.71708975 -5.342377,0.28893185 -7.292303,0.63620175 Z" />
        </g>
    </svg>

    <svg viewBox="-500 -500 1000 1000"
         id="hangingTemplate7"
         class="hangingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignEndpoint" d="M 0,0 0.0070595,144.66931 C -10.758674,171.0666 -78.372645,166.48292 -82.472855,151.17961 -107.43889,130.51192 -107.43889,130.51192 -120.05682,98.832435 -134.92914,89.724405 -125.30386,7.236275 -11.056796,8.121965" />
            <path class="toSquish alignEndpoint" d="M 0,0 0.0070595,144.66931 C 10.772792,171.0666 78.386759,166.48292 82.486969,151.17961 107.453,130.51192 107.453,130.51192 120.07093,98.832435 134.94326,89.724405 125.31752,7.236275 11.070458,8.121965" />
            <path class="" d="M -3.350513,2.2868864 C -3.350513,2.2868864 0.288187,8.1238866 3.139487,2.0658864 3.139487,2.0658864 19.796687,-18.856113 19.748787,-29.740113 19.743887,-40.623113 8.563987,-49.678113 -5.823313,-49.110113 -20.210713,-48.538113 -30.777313,-26.817113 -30.777313,-26.817113 -30.777313,-26.817113 -8.391113,-40.811113 2.293387,-26.166113 12.977887,-11.517114 -3.350513,2.2808864 -3.350513,2.2808864 Z" />
            <path class="" d="M 11.070187,8.1218865 C 18.628387,5.6388865 21.693887,6.2758865 21.691987,2.1808864 21.690087,-1.9131136 18.339887,-1.2641136 10.773487,-3.7381136 7.627587,-4.7671136 3.363387,-6.7841136 -1.13e-4,-6.7821136 -3.362513,-6.7801136 -7.625913,-4.7591136 -10.771813,-3.7261136 -18.333013,-1.2441136 -21.685913,-2.0301136 -21.684013,2.2028864 -21.682013,6.4358865 -18.620213,5.6468865 -11.056813,8.1218865" />
            <g style="fill: #000000" class="braColor">
                <path class="toSquish isHangingBra" d="M -82.473645,151.17995 C -92.994485,146.12828 -102.7278,138.15267 -110.36285,126.28963 -115.06122,118.98981 -118.39466,109.40838 -120.05736,98.829985 -107.17728,130.85954 -3.625e-4,-6.779915 -3.625e-4,-6.779915 -3.625e-4,-6.779915 -107.17728,130.85954 -82.473645,151.17995 Z" />
                <path class="toSquish" d="M -112.98704,121.70634 C -113.71835,128.65153 -111.50231,132.75308 -104.30688,134.42582" />
                <path class="toSquish isHangingBra" d="M 82.491132,151.17995 C 93.011977,146.12828 102.7453,138.15267 110.38034,126.28963 115.07872,118.98981 118.41215,109.40838 120.07485,98.829985 107.19478,130.85954 4.565e-4,-6.779915 4.565e-4,-6.779915 4.565e-4,-6.779915 107.19478,130.85954 82.491132,151.17995 Z" />
                <path class="toSquish" d="M 113.00453,121.70634 C 113.73585,128.65153 111.51981,132.75308 104.32436,134.42582" />
            </g>
            <path class="" d="M 8.343201,-0.00409795 C 8.19168,3.8963595 6.627773,4.7159325 5.254229,6.2212655 3.947158,7.6537875 3.78095,9.3283395 3.488933,11.413814 3.334758,12.514802 2.421636,15.180739 1.317813,15.181282 L 0.006932,15.181926 -1.303949,15.182569 C -2.407763,15.183112 -3.32333,12.518073 -3.478511,11.417236 -3.772399,9.3320495 -3.940137,7.6576615 -5.248542,6.2264235 -6.623461,4.7224415 -8.188108,3.9044054 -8.343201,0.00409825 -8.498286,-3.8961228 -4.609271,-8.32097 -0.003807,-8.3232322 4.601665,-8.3254944 8.494739,-3.9044696 8.343201,-0.00409795 Z" />
            <path class="" d="M 7.253587,0.58988245 8.726116,5.7762975 2.906126,1.7994814 C 3.871883,0.67409265 5.303345,0.24452835 7.253587,0.58988245 Z" />
            <path class="" d="M -7.292303,0.63620175 -8.760092,5.8240605 -2.943738,1.8415294 C -3.910524,0.71708975 -5.342377,0.28893185 -7.292303,0.63620175 Z" />
        </g>
    </svg>

    <svg viewBox="-500 -500 1000 1000"
         id="hangingTemplate8"
         class="hangingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignEndpoint" d="M 0.0077918,0 0.0077918,98.350373 C -7.1060552,115.79334 -51.784429,112.7645 -54.493791,102.65229 -70.991001,88.995367 -70.991001,88.995367 -79.328752,68.061995 -89.156183,62.043538 -86.547583,7.536525 -11.054706,8.121775" />
            <path class="toSquish alignEndpoint" d="M 0.0077918,0 0.0077918,98.350373 C 7.121639,115.79334 51.800013,112.7645 54.509375,102.65229 71.006586,88.995367 71.006586,88.995367 79.344336,68.061995 89.171769,62.043538 86.563167,7.536525 11.07029,8.121775" />
            <path class="toShrink" d="M -3.350513,2.2868864 C -3.350513,2.2868864 0.288187,8.1238866 3.139487,2.0658864 3.139487,2.0658864 19.796687,-18.856113 19.748787,-29.740113 19.743887,-40.623113 8.563987,-49.678113 -5.823313,-49.110113 -20.210713,-48.538113 -30.777313,-26.817113 -30.777313,-26.817113 -30.777313,-26.817113 -8.391113,-40.811113 2.293387,-26.166113 12.977887,-11.517114 -3.350513,2.2808864 -3.350513,2.2808864 Z" />
            <path class="toShrink" d="M 11.070187,8.1218865 C 18.628387,5.6388865 21.693887,6.2758865 21.691987,2.1808864 21.690087,-1.9131136 18.339887,-1.2641136 10.773487,-3.7381136 7.627587,-4.7671136 3.363387,-6.7841136 -1.13e-4,-6.7821136 -3.362513,-6.7801136 -7.625913,-4.7591136 -10.771813,-3.7261136 -18.333013,-1.2441136 -21.685913,-2.0301136 -21.684013,2.2028864 -21.682013,6.4358865 -18.620213,5.6468865 -11.056813,8.1218865" />
            <g style="fill: #ff9955" class="braColor">
                <path class="toSquish isHangingBra" d="M -54.493451,102.65263 C -61.445479,99.314555 -67.877122,94.044383 -72.922251,86.205445 -76.026877,81.381823 -78.229561,75.050543 -79.328251,68.060491 -70.817277,89.225183 0,-6.783021 0,-6.783021 0,-6.783021 -70.817277,89.225183 -54.493451,102.65263 Z" />
                <path class="toSquish" d="M -74.656279,83.176865 C -75.139525,87.766159 -73.675196,90.476406 -68.920546,91.581728" />
                <path class="toSquish isHangingBra" d="M 54.512451,102.65263 C 61.464479,99.314555 67.896122,94.044383 72.941251,86.205445 76.045877,81.381823 78.248561,75.050543 79.347251,68.060491 70.836277,89.225183 0,-6.783021 0,-6.783021 0,-6.783021 70.836277,89.225183 54.512451,102.65263 Z" />
                <path class="toSquish" d="M 74.675279,83.176865 C 75.158525,87.766159 73.694196,90.476406 68.939546,91.581728" />
            </g>
            <path class="toShrink" d="M 8.343201,-0.00409795 C 8.19168,3.8963595 6.627773,4.7159325 5.254229,6.2212655 3.947158,7.6537875 3.78095,9.3283395 3.488933,11.413814 3.334758,12.514802 2.421636,15.180739 1.317813,15.181282 L 0.006932,15.181926 -1.303949,15.182569 C -2.407763,15.183112 -3.32333,12.518073 -3.478511,11.417236 -3.772399,9.3320495 -3.940137,7.6576615 -5.248542,6.2264235 -6.623461,4.7224415 -8.188108,3.9044054 -8.343201,0.00409825 -8.498286,-3.8961228 -4.609271,-8.32097 -0.003807,-8.3232322 4.601665,-8.3254944 8.494739,-3.9044696 8.343201,-0.00409795 Z" />
            <path class="toShrink" d="M 7.253587,0.58988245 8.726116,5.7762975 2.906126,1.7994814 C 3.871883,0.67409265 5.303345,0.24452835 7.253587,0.58988245 Z" />
            <path class="toShrink" d="M -7.292303,0.63620175 -8.760092,5.8240605 -2.943738,1.8415294 C -3.910524,0.71708975 -5.342377,0.28893185 -7.292303,0.63620175 Z" />
        </g>
    </svg>

    <svg viewBox="-500 -500 1000 1000"
         id="hangingTemplateTemplate"
         class="hangingSVG">
        <g class="wholeFox"
           style="fill: #ffffff; stroke: #000000; stroke-width: 0.3px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1">
            <path class="toSquish alignEndpoint" d="" />
            <path class="toSquish alignEndpoint" d="" />
            <path class="" d="M -3.350513,2.2868864 C -3.350513,2.2868864 0.288187,8.1238866 3.139487,2.0658864 3.139487,2.0658864 19.796687,-18.856113 19.748787,-29.740113 19.743887,-40.623113 8.563987,-49.678113 -5.823313,-49.110113 -20.210713,-48.538113 -30.777313,-26.817113 -30.777313,-26.817113 -30.777313,-26.817113 -8.391113,-40.811113 2.293387,-26.166113 12.977887,-11.517114 -3.350513,2.2808864 -3.350513,2.2808864 Z" />
            <path class="" d="M 11.070187,8.1218865 C 18.628387,5.6388865 21.693887,6.2758865 21.691987,2.1808864 21.690087,-1.9131136 18.339887,-1.2641136 10.773487,-3.7381136 7.627587,-4.7671136 3.363387,-6.7841136 -1.13e-4,-6.7821136 -3.362513,-6.7801136 -7.625913,-4.7591136 -10.771813,-3.7261136 -18.333013,-1.2441136 -21.685913,-2.0301136 -21.684013,2.2028864 -21.682013,6.4358865 -18.620213,5.6468865 -11.056813,8.1218865" />
            <g style="fill: #ff5555" class="braColor">
                <path class="toSquish isHangingBra" d="" />
                <path class="toSquish" d="" />
                <path class="toSquish isHangingBra" d="" />
                <path class="toSquish" d="" />
            </g>
            <path class="" d="M 8.343201,-0.00409795 C 8.19168,3.8963595 6.627773,4.7159325 5.254229,6.2212655 3.947158,7.6537875 3.78095,9.3283395 3.488933,11.413814 3.334758,12.514802 2.421636,15.180739 1.317813,15.181282 L 0.006932,15.181926 -1.303949,15.182569 C -2.407763,15.183112 -3.32333,12.518073 -3.478511,11.417236 -3.772399,9.3320495 -3.940137,7.6576615 -5.248542,6.2264235 -6.623461,4.7224415 -8.188108,3.9044054 -8.343201,0.00409825 -8.498286,-3.8961228 -4.609271,-8.32097 -0.003807,-8.3232322 4.601665,-8.3254944 8.494739,-3.9044696 8.343201,-0.00409795 Z" />
            <path class="" d="M 7.253587,0.58988245 8.726116,5.7762975 2.906126,1.7994814 C 3.871883,0.67409265 5.303345,0.24452835 7.253587,0.58988245 Z" />
            <path class="" d="M -7.292303,0.63620175 -8.760092,5.8240605 -2.943738,1.8415294 C -3.910524,0.71708975 -5.342377,0.28893185 -7.292303,0.63620175 Z" />
        </g>
    </svg>



</div>
<script>
    //Let's start with a simple way to make the progress bar function from red to green as it crosses the line, across any amount of time. Shouldn't be all that difficult. Hopefully. It starts out by being seconds per fox, then foxes per second.
    var newFoxTime = 5, //set time to 10s or so, maybe consider inverting this to make it always calcd at foxes per second.
        newFoxProgress = 0;
    var newMergeTime = 10,
        newMergeProgress = 0,
        maxMergeTier = 0,
        mergeMightWork = 1;
    var emptyBoxes = [
        [0, 1, 2, 3, 4, 5, 6, 7, 8]//,
        //[9, 10, 11, 12, 13, 14, 15, 16],
        //[17, 18, 19, 20, 21, 22, 23, 24]
    ],
        boxTiers = [0, 0, 0, 0, 0, 0, 0, 0, 0/*, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0*/],
        boxFoxData = [{}, {}, {}, {}, {}, {}, {}, {}, {}/*, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}*/]; //currently 9+8+8
    var time = 0,
        framesPerSecond = 30,
        foxIsSquishy = 0;
    var heldFoxLocation = 0;
    var trackedCursorX = 0,
        trackedCursorY = 0;
    var currentlyZooming = 1,
        zoomLevel = 0,
        properZoomLevel = 0,
        targetZoomLevel = 0,
        zoomX = 0,
        targetZoomX = 0,
        zoomY = 0,
        targetZoomY = 0,
        focusOnFox = undefined,
        focusZoomLevel = 0,
        focusRestingHeight = 0,
        foxViewBox = undefined,
        experimentalZoom = 0;
    var biggestFoxCreated = 1,
        layersUnlocked = 0;

    var braColors = ["#ff5555", "#9955ff", "#3771c8", "#338000", "#ffdd55", "#ff9955", "#000000"]
    //red purple blue green yellow orange  black
    //var braColors = ["#ff5555", "#ff9955", "#ffdd55", "#338000", "#3771c8", "#9955ff", "#000000"]
    //red orange yellow green blue purple black

    //Here's the basic vector math zone.

    function lerp(a, b, t) {
        return a + (b - a) * t;
    }

    function unlerp(a, b, pos) {
        if (a != b) {
            return (pos - a) / (b - a);
        } else {
            return 1;
        }

    }

    function angleDistillation(x, y) {
        var answer = Math.atan(y / x);
        if (x < 0) {
            answer += Math.PI;
        };
        if (x == 0 && y == 0) {
            answer = 0;
        }
        return answer;
    }

    function clamp(number, max, min) {
        return Math.max(min, Math.min(number, max));
    }

    function getSizeMultiplier(tier, pseudo = 0) {
        //when pseudo is 1, it allows the filled boxes to have size multipliers (for the express purpose of creating hanging models)
        if (tier % 7 != 0 && tier > 7) {
            return Math.E ** ((tier % 7 + 1) * 0.125 * Math.log(19 / 6)) * (240 / 174.380) * (6 / 19);
        } else if (pseudo && (tier > 7) && tier % 7 == 0) {
            return Math.E ** (1.12 * Math.log(19 / 6)) * (240 / 174.380) * (6 / 19);
        } else {
            return 1;
        }
        //This function will determine the factor the visual boob size of the tier 8 SVG needs to be multiplied by in order to cover all tiers beyond 8 (except the laying models that fill the box).
    }


    function simpleEnvelope(squishFactor, paths, considerations, raiseFactor, box) {
        //This function accepts a valid D value and outputs a valid D value (or an array thereof).
        //This function assumes a space between each coordinate pair and letter and that you're *not* using V or H. It must be absolute as well. Any non-rectangular deformation may break paths if you don't have overlap.
        var pathIsString = 0;
        var newPaths = {};
        var sizeMultiplier = getSizeMultiplier(boxTiers[box]);
        if (boxFoxData[box].isDangling == 1) {
            sizeMultiplier = getSizeMultiplier(boxTiers[box], 1)
        }
        //This variable scales a fox's visual boob size based on how much it changes from the given template. It's exponential so the boob size increase is constant from here onwards.



        if (typeof paths == "string") {
            paths = [paths];
            pathIsString = 1;
        }
        var maxSquishFactor = squishFactor;
        for (const key in paths) {
            var pointArray = paths[key].split(" ")
            var newPath = ""
            var newPathArray = [];
            var firstHandleFactor;
            for (i = 0; i < pointArray.length; i++) {
                if (pointArray[i].includes(",")) {
                    let oldPoint = pointArray[i].split(",");
                    oldPoint[0] *= sizeMultiplier;
                    oldPoint[1] *= sizeMultiplier;
                    let newPointX = oldPoint[0] * squishFactor;
                    if (considerations.includes("fillingBox")) {
                        newPointX = oldPoint[0];
                        squishFactor = (maxSquishFactor - 1) * (1 - Math.abs(oldPoint[0] / 80)) + 1; //The divisor determines the pivit point of the booba, from 0 to 120.
                    }
                    let newPointY = oldPoint[1] / squishFactor;
                    if (considerations.includes("isHangingBra") && Math.abs(oldPoint[0] * 1) < 0.05) {
                        newPointY = oldPoint[1] / sizeMultiplier / zoomFactorX(box, 0);
                        //On the hanging bra, the bra connector doesn't move.
                    } else if (considerations.includes("isLayingBra") && Math.abs(oldPoint[0]) < 0.05) {
                        //newPointY = (oldPoint[1] - raiseFactor * sizeMultiplier) / (zoomFactorY(box, 0)) + raiseFactor * (2 - squishFactor) * sizeMultiplier; //The *1 ensures that the oldPoint becomes a number, which is necessary. So don't delete that bit.
                        //The above code was a bit delusional. The line below is how it really works, from the beginning.
                        newPointY = (oldPoint[1] / sizeMultiplier - raiseFactor) / zoomFactorX(box, 0) + raiseFactor * sizeMultiplier / squishFactor
                        newPointX = 0
                    } else if (considerations.includes("alignStartpoint") && i == 1) {
                        //This prevents the area where the boob connects with the head from disconnecting.
                        if (considerations.includes("scaleStartpoint")) {
                            newPointX = oldPoint[0] / zoomFactorX(box, 0) / sizeMultiplier;
                            firstHandleFactor = newPointX - oldPoint[0];

                        } else {
                            newPointX = oldPoint[0];
                        }
                        newPointY = oldPoint[1] / maxSquishFactor;
                    } else if (considerations.includes("alignStartpoint") && i == pointArray.length - 1) {
                        //This prevents the cleavage from sticking up past the fox's head on higher layers

                        newPointX = 0
                        newPointY = (oldPoint[1] / sizeMultiplier - raiseFactor) / zoomFactorX(box, 0) + raiseFactor * sizeMultiplier / squishFactor
                        //newPointY = raiseFactor * sizeMultiplier / squishFactor


                    } else if (considerations.includes("scaleStartpoint") && i == 3) {
                        newPointX = (oldPoint[0] * 1 + firstHandleFactor) * squishFactor; //Consider increasing this for if ever I need a more extreme squish at larger levels
                        //This is for the hanging boob btw
                    } else if (considerations.includes("scaleStartpoint") && i == pointArray.length - 1 && boxTiers[box] % 7 == 0) {
                        //The point where the cleavage connects to the head.
                        newPointY = (oldPoint[1] - raiseFactor) / zoomFactorX(box, 0) + raiseFactor / squishFactor

                    } else if (considerations.includes("alignEndpoint") && i == pointArray.length - 1) {

                        oldPoint[1] /= sizeMultiplier * zoomFactorY(box, 0);
                        if (squishFactor < 1) {
                            newPointY = oldPoint[1];
                        } else {
                            newPointY /= sizeMultiplier * zoomFactorY(box, 0);
                        }
                        //This prevents the area where the boob connects with the head from disconnecting. When the boob is squished rather than stretched, it's allowed to overlap the fox for effect.
                        newPointX = oldPoint[0] / sizeMultiplier / zoomFactorX(box, 0);

                    } else if (considerations.includes("alignEndpoint") && i == 1) {
                        newPointX = 0
                    }
                    newPath += newPointX + "," + newPointY;
                    newPathArray.push([newPointX, newPointY]);
                } else {
                    try {
                        if (pointArray[i - 1].includes("V")) {
                            let newPointX = newPathArray[newPathArray.length - 1][0];
                            let newPointY = pointArray[i] / squishFactor;
                            newPath += newPointX + "," + newPointY;
                            newPathArray.push([newPointX, newPointY]);
                        } else if (pointArray[i - 1].includes("H")) {
                            let newPointX = pointArray[i] * squishFactor;
                            let newPointY = newPathArray[newPathArray.length - 1][1];
                            newPath += newPointX + "," + newPointY;
                            newPathArray.push([newPointX, newPointY]);
                        } else {
                            newPath += pointArray[i];
                        }
                    } catch {
                        newPath += pointArray[i];
                    }
                }
                if (i < pointArray.length) {
                    newPath += " ";
                }
            }
            newPaths[key] = newPath;
        }
        if (pathIsString) {
            newPaths = newPaths[0];
        }
        return newPaths;
    }


    function applySquish(box, squishFactor) {
        //Given a box, tier, and a scaling factor, it decides which path to envelope and which to use other transforms on.
        var wholeFox, templateFox;
        var raiseFactor = boxFoxData[box].raiseFactor;

        var roundedHangingTier = boxTiers[box],
            roundedLayingTier = boxTiers[box]
        if (boxTiers[box] > 7 && boxTiers[box] % 7 != 0) {
            roundedHangingTier = 8;
            roundedLayingTier = 8
        } else if (boxTiers[box] % 7 == 0 && boxTiers[box] > 7) {
            roundedHangingTier = 8;
            roundedLayingTier = 7;
        }



        if (boxFoxData[box].isDangling) {
            templateFox = document.getElementById("hangingTemplate" + roundedHangingTier).getElementsByClassName("wholeFox")[0];
            //console.log(document.getElementById("hangingFoxBox" + box))
            wholeFox = document.getElementById("hangingFoxBox" + box).getElementsByClassName("wholeFox")[0];
            //console.log(wholeFox)
        } else {
            templateFox = document.getElementById("layingTemplate" + roundedLayingTier).getElementsByClassName("wholeFox")[0];
            wholeFox = document.getElementById("foxBox" + box).getElementsByClassName("wholeFox")[0];
        }
        var i = 0;
        for (const path of templateFox.getElementsByClassName("toSquish")) {
            let considerations = [];
            if (boxTiers[box] > 7 && path.classList.contains("alignStartpoint")) {
                considerations.push("scaleStartpoint")
            }
            for (u = 1; u < path.classList.length; u++) {
                considerations.push(path.classList[u]);
            }
            if (!(boxFoxData[box].isDangling) && boxTiers[box] % 7 == 0) {
                considerations.push("fillingBox");
            }
            wholeFox.getElementsByClassName("toSquish")[i].setAttribute("d", simpleEnvelope(squishFactor, path.getAttribute("d"), considerations, raiseFactor, box));
            i++
        }
        //var raiseFactor = templateFox.getElementsByClassName("toRaise")[1].getAttribute("d").split(" ")[1].split(",")[1] * 1;
        // console.log(raiseFactor);
        if (boxTiers[box] < 8) {
            for (let o = 0; o < templateFox.getElementsByClassName("toRaise").length; o++) {
                wholeFox.getElementsByClassName("toRaise")[o].setAttribute("transform", "translate(0, " + ((1 / squishFactor - 1) * raiseFactor) + ")")
            }
        } else {
            for (let o = 0; o < templateFox.getElementsByClassName("toRaise").length; o++) {
                wholeFox.getElementsByClassName("toRaise")[o].setAttribute("transform", "translate(0, " + (-raiseFactor / zoomFactorY(box, 0) + raiseFactor * getSizeMultiplier(boxTiers[box]) / squishFactor) + ") scale(" + (1 / zoomFactorX(box, 0)) + "," + (1 / zoomFactorY(box, 0)) + ")")
                //The following code is now abandoned for being dogwater: (((1 / (squishFactor) - getSizeMultiplier(boxTiers[box]) / zoomFactorY(box, 0)) + (getSizeMultiplier(boxTiers[box])-1)) * raiseFactor * getSizeMultiplier(boxTiers[box]))
                //It's pretty simple: First put it to the ground, then raise it to where it needs to be.
                wholeFox.getElementsByClassName("toRaise")[o].setAttribute("style", "stroke-width:" + Math.min(0.3, (0.5 * (6 / 19) ** (foxLayer(box) - zoomLevel))) * zoomFactorX(box, 0) + "px")
            }

            for (let o = 0; o < templateFox.getElementsByClassName("toShrink").length; o++) {
                wholeFox.getElementsByClassName("toShrink")[o].setAttribute("transform", "scale(" + (1 / zoomFactorX(box, 0)) + "," + (1 / zoomFactorY(box, 0)) + ")")
                //The overall head's just shrunken, with the transformation center being the origin. Easy enough.
                wholeFox.getElementsByClassName("toShrink")[o].setAttribute("style", "stroke-width:" + Math.min(0.3, (0.5 * (6 / 19) ** (foxLayer(box) - zoomLevel))) * zoomFactorX(box, 0) + "px")
            }

        }
        //adjust the stroke width accordingly
        //wholeFox.setAttribute("stroke-width", Math.min(0.3, (0.3 * (6/19) ** (foxLayer(box) - zoomLevel))) + "px");
        wholeFox.style = "fill: #ffffff; stroke: #000000; stroke-width: " + Math.min(0.5, (0.3 * (6 / 19) ** (foxLayer(box) - zoomLevel))) + "px; stroke-linecap: round; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-dasharray: none; stroke-opacity: 1"
    }

    function foxLayer(location) {
        return Math.max(Math.ceil((location) / 8) - 1, 0);

    }

    function zoomFactorX(location, affectedByZoom = 1) {
        let outOfTierFactor = 0;
        if (Math.floor((boxTiers[location] - 1) / 7) > foxLayer(location)) {
            outOfTierFactor = 1;
        }
        return (6 / 19) ** (-foxLayer(location) + zoomLevel * affectedByZoom - outOfTierFactor);
    }

    function zoomFactorY(location, affectedByZoom = 1) {
        let outOfTierFactor = 0;
        if (Math.floor((boxTiers[location] - 1) / 7) > foxLayer(location)) {
            outOfTierFactor = 1;
        }
        return (15 / 49) ** (-foxLayer(location) + zoomLevel * affectedByZoom - outOfTierFactor);
    }

    function getCurrentSquish(location) {
        let squishAngle = time / 1.7 - location / 9 - boxFoxData[location].tempSquishAngle
        //When tempSquishAngle is set, I want it + squishAngle to equal -pi/4 or something in that quadrant so that it starts off descending and descended. However, its decaying nature makes that volatile. The only solution is for me to find the modulus of the current squish and add that to the squishangle so that the existing offset is counteracted and decays without extra loops.
        let squishFactor = 1 + (0.06 + boxFoxData[location].tempSquishMagnitude) * Math.cos(Math.PI * 2 * squishAngle);
        return squishFactor;
        //abooga
        //return 1.1;
    }

    function updateFoxPhysics(location) {

        var offsetGravityForce = (1 - (0.002 * boxFoxData[location].offsetDecayFactor) ** (1 / framesPerSecond));
        boxFoxData[location].holdingOffsetX *= (0.002 * boxFoxData[location].offsetDecayFactor) ** (1 / framesPerSecond);
        boxFoxData[location].holdingOffsetY *= (0.002 * boxFoxData[location].offsetDecayFactor) ** (1 / framesPerSecond);

        if (location != heldFoxLocation) {
            boxFoxData[location].holdingOffsetY += Math.abs(boxFoxData[location].holdingOffsetX) * (1 - (0.002 * boxFoxData[location].offsetDecayFactor) ** (1 / framesPerSecond)) * 0.5;
        }


        let boobDeltaX = boxFoxData[location].hangPointX - (boxFoxData[location].heldPointX + boxFoxData[location].holdingOffsetX);
        let boobDeltaY = boxFoxData[location].hangPointY - (boxFoxData[location].heldPointY + boxFoxData[location].holdingOffsetY);
        //The deltas are the distances from the fox's head to the hang point
        let boobAngle = angleDistillation(boobDeltaX, boobDeltaY),
            boobMagnitude = ((boobDeltaX ** 2 + boobDeltaY ** 2) ** 0.5) / boxFoxData[location].initialHangPointLength;
        //Angle and magnitude are pretty straightforward. Angle is in radians and magnitude is in a multiplier of the original distance.

        let weightMultiplier = -boxFoxData[location].raiseFactor * getSizeMultiplier(boxTiers[location], 1);


        let springiness = 5000,
            internalTier = (boxTiers[location] - 1) % 7 + 1,
            momentum = 0.7 + internalTier * 0.1 + (internalTier ** 2) * 0.05;

        if (boxTiers[location] > 7 && internalTier != 7) {
            momentum *= boxFoxData[location].initialHangPointLength / document.getElementById("hangingTemplate" + internalTier).getElementsByClassName("toSquish")[0].getAttribute("d").split(" ")[2].split(",")[1];
            //This is the line that (hopefully) fixes physics on upper-layer foxes, multiplying their momentum by how much larger they are than their corresponding first-layer equivalents.
        }



        //adopting the runge-kotta may fix this.

        if (boxTiers[location] > 7) {
            //momentum *=  2 ** ((Math.floor(boxTiers[location] - 1) / 7)); //It's done like this instead of with foxLayer() to account for foxes moving to higher layers.
        }
        //momentum = 1;
        //springiness = weightMultiplier * 200 * (0.7 + ((boxTiers[location] - 1) % 7) )//* 0.1 + 0.05 * ((boxTiers[location] - 1) % 7) ** 2);
        //momentum = Math.abs(weightMultiplier) ** 1 * -1 / 40;
        //Original value was 0.8 + 0.2x + 0.02x^2, but that concentrated the jiggle in the middle tiers. Current method concentrates it at around T6, but a spike to get to T7 may not be the best.
        //Consider at some later point making the acceleration or momentum properly scale with the initial hang point rather than just guessing based on tier.

        let accelX = -springiness * Math.cos(boobAngle) * (boobMagnitude / zoomFactorX(location) - 0.7) * zoomFactorX(location);
        let accelY = -springiness * (Math.sin(boobAngle) * (boobMagnitude / zoomFactorY(location) - 0.7) - 0.3) * zoomFactorY(location);

        /* if (boobMagnitude > 1.4 || boobMagnitude < 0.6) {
               accelX *= 1 + (Math.abs(boobMagnitude - 1) - 0.4) * 10
               accelY *= 1 + (Math.abs(boobMagnitude - 1) - 0.4) * 10
               //This produces too much acceleration.
           } */


        boxFoxData[location].hangPointX += boxFoxData[location].velocityX * (1 / framesPerSecond);
        boxFoxData[location].hangPointY += boxFoxData[location].velocityY * (1 / framesPerSecond);

        boxFoxData[location].velocityX += accelX * 1 / (framesPerSecond);
        boxFoxData[location].velocityY += accelY * 1 / framesPerSecond;
        //Instead of just applying friction to them, use this area to separate them into parallel and perpendicular velocities, apply friction to one, then combine them again.
        //boxFoxData[heldFoxLocation].velocityX *= 0.002 ** (1 / (framesPerSecond * momentum));
        //boxFoxData[heldFoxLocation].velocityY *= 0.002 ** (1 / (framesPerSecond * momentum));
        //Here begins the separate friction test
        boobDeltaX = boxFoxData[location].hangPointX - (boxFoxData[location].heldPointX + boxFoxData[location].holdingOffsetX);
        boobDeltaY = boxFoxData[location].hangPointY - (boxFoxData[location].heldPointY + boxFoxData[location].holdingOffsetY);
        boobAngle = angleDistillation(boobDeltaX, boobDeltaY)

        let parallelVelocity = boxFoxData[location].velocityX * Math.cos(boobAngle) + boxFoxData[location].velocityY * Math.sin(boobAngle),
            perpendicularVelocity = -boxFoxData[location].velocityX * Math.sin(boobAngle) + boxFoxData[location].velocityY * Math.cos(boobAngle);

        parallelVelocity *= 0.002 ** (1 / (framesPerSecond * momentum));
        perpendicularVelocity *= 0.02 ** (1 / (framesPerSecond * momentum));



        boxFoxData[location].velocityX = parallelVelocity * Math.cos(-boobAngle) + perpendicularVelocity * Math.sin(-boobAngle);
        boxFoxData[location].velocityY = -parallelVelocity * Math.sin(-boobAngle) + perpendicularVelocity * Math.cos(-boobAngle);

        updateHangingSquish(location);
    }

    //Math zone ends.

    let ticker = setInterval(renderFrame, 1000 / framesPerSecond);

    

    function createFox(location, isMoving = 0) {
        //This function takes the location, reads that location's tier, and creates a fox of the corresponding tier there. This applies to all instances of a fox being made, combined, or moved.
        //The second parameter is the fox's information/lore object. The third parameter is falling context, if necessary.
        var tier = boxTiers[location];
        // var newFox = document.createElement("div");
        if (tier == 0) {
            if (!emptyBoxes[0].includes(location)) {
                emptyBoxes[0].push(location);
                //handles the possibility of a box not properly adding itself to the emptyboxes list.
            }

            return;
        }
        var newFox
        if (tier <= 7) {
            newFox = document.getElementById("layingTemplate" + tier).cloneNode(1);
        } else if (tier % 7 != 0) {
            newFox = document.getElementById("layingTemplate8").cloneNode(1);
        } else if (tier % 7 == 0) {
            newFox = document.getElementById("layingTemplate7").cloneNode(1);
        }
        newFox.id = "fox" + location;
        boxFoxData[location].tempSquishMagnitude = 0.1;
        boxFoxData[location].tempSquishAngle = ((time / 1.7 - location / 9) % 1) + 1.40;
        boxFoxData[location].raiseFactor = newFox.getElementsByClassName("toRaise")[1].getAttribute("d").split(" ")[1].split(",")[1] * 1 //* getSizeMultiplier(tier);
        boxFoxData[location].restingCenterHeight = (newFox.getElementsByClassName("toRaise")[2].getAttribute("d").split(" ").at(-2).split(",")[1] * 1 - boxFoxData[location].raiseFactor) / zoomFactorY(location, 0) + (boxFoxData[location].raiseFactor * getSizeMultiplier(tier));
        //resting center height currently isn't dynamic to visually smaller foxes, so that'll need to be fixed. It's a simple multiplier. I guess I'll do it now.
        boxFoxData[location].isDangling = 0;
        boxFoxData[location].isTargeted = 0;

        if (boxFoxData[location].isReserved != undefined) {
            boxFoxData[boxFoxData[location].isReserved].isReserved = undefined;
        }
        boxFoxData[location].isReserved = undefined;

        mergeMightWork = 1;
        if (boxTiers[location] > biggestFoxCreated) {
            biggestFoxCreated = boxTiers[location];
            maxMergeTier = biggestFoxCreated - 1
        }

        newFox.getElementsByClassName("braColor")[0].style.fill = braColors[(tier - 1) % 7]

        //  newFox.setAttribute("class", "foxPlaceholder");
        //  newFox.innerText = tier;
        document.getElementById("foxBox" + location).appendChild(newFox);
        if (isMoving) {
            newFox.style.display = "none";
        } else {
            foxCanBeDragged(newFox);
        }

    }

    function createMovingFox(location, targetBox = -1, returningHome = 0) {
        //The location is the foxBox that was picked up. The targetBox is the box the fox is traveling to, or 0 if it's held by the cursor.
        var heldfox;
        if (boxTiers[location] <= 7) {
            heldFox = document.getElementById("hangingTemplate" + boxTiers[location]).cloneNode(1);
        } else {
            heldFox = document.getElementById("hangingTemplate" + 8).cloneNode(1);
        }

        var layingFox = document.getElementById("fox" + location);
        layingFox.style.display = "none";
        heldFox.id = "hangingFox" + location;

        heldFox.getElementsByClassName("braColor")[0].style.fill = braColors[(boxTiers[location] - 1) % 7]
        boxFoxData[location].initialHangPointLength = heldFox.getElementsByClassName("toSquish")[0].getAttribute("d").split(" ")[2].split(",")[1] * getSizeMultiplier(boxTiers[location], 1);

        var targetX, targetY
        if (targetBox != -1) {
            let targetRect = document.getElementById("foxBox" + targetBox).getBoundingClientRect();
            targetX = (targetRect.left + targetRect.right) / 2;
            targetY = targetRect.bottom - boxFoxData[location].initialHangPointLength * zoomFactorY(targetBox);
            boxFoxData[location].offsetDecayFactor = 5 + 5 * Math.random();
            boxFoxData[targetBox].isTargeted = 1;
            if (emptyBoxes[foxLayer(targetBox)].includes(targetBox)) {
                //When a box being moved towards is empty, it's removed from the emptyboxes list so that a new fox can't be created there accidentally. I will also need to prevent the player from being able to place a fox in its way if it's tiering up.
                //emptyBoxes[foxLayer(targetBox)].splice(emptyBoxes[foxLayer(targetBox)].indexOf(targetBox), 1);
                //This code is currently removing the empty boxes twice over, so don't do that maybe.
            }

        } else {
            targetX = trackedCursorX;
            targetY = trackedCursorY;
            boxFoxData[location].offsetDecayFactor = 1;
        }
        boxFoxData[location].movingToTarget = targetBox;


        heldFox.setAttribute("viewBox", -targetX + " " + (-targetY - 0.3) + " " + window.innerWidth + " " + window.innerHeight);

        boxFoxData[location].layer = foxLayer(location);

        

        let rect = layingFox.parentNode.getBoundingClientRect();
        boxFoxData[location].hangPointX = ((rect.left + rect.right) / 2);
        boxFoxData[location].hangPointY = (rect.bottom);
        boxFoxData[location].holdingOffsetX = -targetX + ((rect.left + rect.right) / 2);
        let squishDiff = (1/getCurrentSquish(location) - 1) * boxFoxData[location].raiseFactor * getSizeMultiplier(boxTiers[location]); //Check whether the multiplier is needed here, and if it needs pseudo.
        boxFoxData[location].holdingOffsetY = -targetY + (rect.bottom) + ((boxFoxData[location].restingCenterHeight) - 2.3 + squishDiff) * zoomFactorY(location, 1)

        boxFoxData[location].isDangling = 1;
        boxFoxData[location].heldPointX = targetX
        boxFoxData[location].heldPointY = targetY


        boxFoxData[location].velocityX = 0;
        boxFoxData[location].velocityY = 0;
        //The hangPoint is the location onscreen where the cleavage is. The holdingOffset is the location relative to the cursor where the fox's centerpoint is.

        //document.getElementById("held").appendChild(heldFox);

        var movingFoxBox = document.getElementById("held").cloneNode(0);
        movingFoxBox.id = "hangingFoxBox" + location;
        document.getElementById("movingContainer").appendChild(movingFoxBox);
        movingFoxBox.appendChild(heldFox);

        //console.log(heldFox)


        updateHangingSquish(location);
    }

    function createNewLayer() {
        layersUnlocked++;
        var newLayer = document.createElement("div")
        newLayer.id = "foxLayerWrapper" + layersUnlocked
        newLayer.className = "foxLayerWrapper"
        emptyBoxes.push([])
        for (i = 0; i < 8; i++) {
            let newBox = document.createElement("div")
            newBox.id = "foxBox" + (layersUnlocked * 8 + i + 1)
            newBox.className = "innerFoxBox"
            emptyBoxes[layersUnlocked].push((layersUnlocked * 8 + i + 1));
            boxFoxData.push({})
            boxTiers.push(0)
            newLayer.appendChild(newBox)
        }
        document.getElementById("outerFoxBox").prepend(newLayer)
        updateZoom();
        checkButtons();
    }

    function putFoxDown(location) {
        boxFoxData[location].isDangling = 0;

        var sourceBoxElement = document.getElementById("foxBox" + location);
        var hangingBox = document.getElementById("hangingFoxBox" + location);

        var sourceBox = location * 1;
        var targetSelected = 0;
        var box, targetBox;
        try {
            if (boxFoxData[sourceBox].movingToTarget != -1) {

                //If the box is automatically moving, it ignores its actual location and instead just snaps to the desired target.
                targetBox = boxFoxData[sourceBox].movingToTarget * 1;
            } else {
                box = document.elementFromPoint(boxFoxData[location].heldPointX, boxFoxData[location].heldPointY).closest(".innerFoxBox");
                targetBox = box.id.replace("foxBox", "") * 1;
            }
            targetSelected = 1;
        } catch {
            box = null;
        }
        if (targetSelected && (foxLayer(sourceBox) == foxLayer(targetBox) || (boxTiers[sourceBox] - 1) / 7 == foxLayer(targetBox)) && (boxFoxData[targetBox].isReserved == undefined || boxFoxData[targetBox].isReserved == sourceBox)) {

            hangingBox.remove(); //The held object is deleted, removing the hanging fox model
            document.getElementById("fox" + sourceBox).remove();
            try {
                document.getElementById("fox" + targetBox).remove();
            } catch { }//Both laying foxes, one of which is likely invisible, are removed, creating room for new ones to be made.

            if (boxFoxData[targetBox].isDangling == 1) {
                document.getElementById("hangingFoxBox" + targetBox).remove();
                if (targetBox == heldFoxLocation) {

                    targetBox = sourceBox
                    //If the player is holding the fox that's landed on, it isn't affected.

                    /*
                    document.onmousemove = null;
                    document.onmouseup = null;
                    heldFoxLocation = -1;
                    document.body.classList.remove("alwaysPointer");
                    */

                }
            }

            if (targetBox == sourceBox) {
                createFox(sourceBox);
            } else if (boxTiers[sourceBox] == boxTiers[targetBox]) {
                if (boxTiers[targetBox] % 7 != 0) {
                    //If the combined foxes would fit in the same layer, they combine as normal.
                    boxTiers[sourceBox] = 0;
                    boxTiers[targetBox] += 1;
                    createFox(targetBox);
                    emptyBoxes[foxLayer(sourceBox)].push(sourceBox);
                } else {
                    if (boxTiers[sourceBox] / 7 > layersUnlocked) {
                        createNewLayer()
                    }

                    if (emptyBoxes[foxLayer(targetBox) + 1].length > 0) {
                        //If the next layer up is empty, a random empty space in that layer is chosen as the new target. Both spaces are cleared.
                        boxTiers[sourceBox] = 0;
                        boxTiers[targetBox] += 1;
                        var nextTierBox = emptyBoxes[foxLayer(targetBox) + 1][Math.floor(Math.random() * emptyBoxes[foxLayer(targetBox) + 1].length)] * 1;
                        createFox(targetBox)
                        createMovingFox(targetBox, nextTierBox);
                        boxFoxData[nextTierBox].isReserved = targetBox;
                        boxFoxData[targetBox].isReserved = targetBox;
                        emptyBoxes[foxLayer(sourceBox)].push(sourceBox);
                        emptyBoxes[foxLayer(nextTierBox)].splice(emptyBoxes[foxLayer(nextTierBox)].indexOf(nextTierBox), 1);
                        console.log(nextTierBox)
                    } else {
                        //If the next layer up is full, the foxes just swap places.
                        let temp = boxTiers[sourceBox];
                        boxTiers[sourceBox] = boxTiers[targetBox];
                        boxTiers[targetBox] = temp;
                        createFox(targetBox);
                        createFox(sourceBox);

                    }
                }


            } else if (boxTiers[targetBox] == 0 && (boxFoxData[targetBox].isReserved == undefined || boxFoxData[targetBox].isReserved == sourceBox)) {
                console.log(boxFoxData[targetBox].isReserved + "," + sourceBox)
                boxTiers[targetBox] = boxTiers[sourceBox] * 1;
                boxTiers[sourceBox] = 0;
                createFox(targetBox);
                emptyBoxes[foxLayer(sourceBox)].push(sourceBox);
                if (emptyBoxes[foxLayer(targetBox)].includes(targetBox)) {
                    emptyBoxes[foxLayer(targetBox)].splice(emptyBoxes[foxLayer(targetBox)].indexOf(targetBox), 1);
                }

                //if the box is being targeted by a fox moving up in layers, nothing can be put in that box, even manually.

            } else if (boxTiers[sourceBox] != boxTiers[targetBox] && boxTiers[targetBox] != 0) {
                let temp = boxTiers[sourceBox];
                boxTiers[sourceBox] = boxTiers[targetBox];
                boxTiers[targetBox] = temp;



                createFox(targetBox);
                createFox(sourceBox);

            } else {
                //this is the catch for if a box is targeted somehow yet doesn't meet any of these requirements. It does nothing, but at least I know what the problem is.
                Console.log("The dropFox function didn't find any cases")
            }



        } else {
            //This executes whenever the fox is dropped in an incompatable location, it just has the fox return to its previous box. I can compress this into a function at some point.
            boxFoxData[sourceBox].movingToTarget = sourceBox;
            if (heldFoxLocation == sourceBox) {
                heldFoxLocation = -1;
            }

            let targetRect = document.getElementById("fox" + sourceBox).parentNode.getBoundingClientRect();
            boxFoxData[sourceBox].holdingOffsetX += -((targetRect.left + targetRect.right) / 2 + 1) + boxFoxData[sourceBox].heldPointX;
            boxFoxData[sourceBox].holdingOffsetY += -(targetRect.bottom - boxFoxData[sourceBox].initialHangPointLength * zoomFactorY(sourceBox)) + boxFoxData[sourceBox].heldPointY;

            boxFoxData[sourceBox].heldPointX = (targetRect.left + targetRect.right) / 2 + 1;
            boxFoxData[sourceBox].heldPointY = targetRect.bottom - boxFoxData[sourceBox].initialHangPointLength * zoomFactorY(sourceBox);

            boxFoxData[location].isDangling = 1;


            /*hangingBox.remove();
            document.getElementById("fox" + sourceBox).remove();
            createFox(sourceBox)*/




            /*
            if (targetSelected == 0) {
                hangingBox.remove()
                createFox(sourceBox)
            }
            */

        }
        /*  for (const box of document.getElementsByClassName("innerFoxBox currentArea")) {
              if (box.matches(':hover')) {
                  targetSelected = 1;


              }
          }*/
        //This handles if the fox was dropped outside of any existing box. Animate later.
        updateLayingSquish(sourceBox)
        if (targetBox) {
            updateLayingSquish(targetBox)
        }

        if (sourceBox == heldFoxLocation) {
            heldFoxLocation = -1;
        }


    }

    function foxCanBeDragged(element) {
        element.getElementsByClassName("wholeFox")[0].onmousedown = draggingMouse;
        var deltaX = 0, deltaY = 0;
        var formerCursorX = 0; formerCursorY = 0;
        var location = element.parentNode.id.replace("foxBox", "") * 1;
        var tier = boxTiers[location];

        function pickUpFox(mouseX, mouseY) {
            document.getElementById("held").style.display = "inline";

            //Add event listeners for mousemove and mouseup (though I will have to make squish and swing depend on the interval as mousemove is unreliable.)
            //The mousemove listener will move the "holding"" invisible div, which contains the fox itself. The SVG will have to be made arbitrarily large to account for all ways the fox can be swung. The center of the coordinate grid will always be the location of the cursor.
            //In the end I will have to just delete the original fox and create a new one, as the SVGs are too different to transfer over. The box it came from will be remembered and used when considering drop behavior.
            //When the fox is released while not being over a box or the quest submission area, they'll fall through the bottom of the screen (make sure to not allow scrolling in that direction) and fall from the top onto their original tile. Use fast speeds and follow-up jiggle to conceal whatever clunkiness is there. I think I'll use CSS animations for that. Catching the fox will be an interesting challenge.
            //document.getElementById("held").style.left = mouseX + "px";
            //document.getElementById("held").style.top = mouseY + "px";
            trackedCursorX = mouseX;
            trackedCursorY = mouseY;


            heldFoxLocation = location;
            createMovingFox(location, -1);

            deltaX = 0;
            deltaY = 0;
            formerCursorX = mouseX;
            formerCursorY = mouseY;

            trackedCursorX = mouseX;
            trackedCursorY = mouseY;
            //document.getElementById("held").appendChild(heldFox);
        }

        function movingFox(mouseX, mouseY) {
            //document.getElementById("held").style.left = mouseX + "px";
            //document.getElementById("held").style.top = mouseY + "px";


            deltaX = mouseX - trackedCursorX;
            deltaY = mouseY - trackedCursorY;
            formerCursorX = mouseX;
            formerCursorY = mouseY;

            trackedCursorX = mouseX;
            trackedCursorY = mouseY;

            //This block will add inertia to the boobs; moving the fox along the cleavage line will only move the hangpoint a fraction of where it should.
            let boobDeltaX = boxFoxData[location].hangPointX - trackedCursorX - boxFoxData[location].holdingOffsetX;
            let boobDeltaY = boxFoxData[location].hangPointY - trackedCursorY - boxFoxData[location].holdingOffsetY;

            let boobAngle = angleDistillation(boobDeltaX, boobDeltaY);
            let movingAngle = angleDistillation(deltaX, deltaY);
            let inertiaFactor = Math.abs(Math.cos(boobAngle - movingAngle));

            boxFoxData[location].hangPointX += deltaX * inertiaFactor * 0.5;
            boxFoxData[location].hangPointY += deltaY * inertiaFactor * 0.5;
            //Here ends the inertia block. The 0.5 may could use a tweak. Maybe it can be a variable.

            boxFoxData[location].heldPointX = mouseX
            boxFoxData[location].heldPointY = mouseY

            document.getElementById("hangingFox" + location).setAttribute("viewBox", -mouseX + " " + (-mouseY + 0.3) + " " + window.innerWidth + " " + window.innerHeight);

            updateHangingSquish(location);
        }



        function draggingMouse(e) {
            e = e || window.event;
            e.preventDefault();
            pickUpFox(e.clientX, e.clientY);
            document.onmouseup = stopDraggingMouse;
            document.onmousemove = draggedMouse;
            document.body.classList.add("alwaysPointer");
        }

        function draggedMouse(e) {
            e = e || window.event;
            e.preventDefault();
            movingFox(e.clientX, e.clientY);
        }

        function stopDraggingMouse() {
            //Determine where it stopped being dragged, and what to do about it. Setting display to invisible is a placeholder.
            putFoxDown(location);
            document.onmousemove = null;
            document.onmouseup = null;
            document.body.classList.remove("alwaysPointer");
        }

        element.getElementsByClassName("wholeFox")[0].addEventListener('touchstart', function starting(e) {
            // grab the location of touch
            var touchLocation = e.targetTouches[0];

            pickUpFox(touchLocation.pageX, touchLocation.pageY);
            //document.onmouseup = closeDragElement;
        })

        element.getElementsByClassName("wholeFox")[0].addEventListener('touchmove', function moving(e) {
            // grab the location of touch
            var touchLocation = e.targetTouches[0];

            try {
                movingFox(touchLocation.pageX, touchLocation.pageY);
            } catch { }
        })


        element.getElementsByClassName("wholeFox")[0].addEventListener('touchend', function dropping(e) {
            try {
                putFoxDown(location);
            } catch { }


            //document.onmouseup = null;
            //document.onmousemove = null;
        })

    }

    function updateLayingSquish(location) {
        if (boxTiers[location] != 0 && boxFoxData[location].isDangling == 0) {
            
            var foxGroup = document.getElementById("foxBox" + location).getElementsByClassName("wholeFox")[0];

            //SquishAngle is measured in revolutions. tempSquishAngle subtracts from it, but decays, making it seem like it jiggles faster until it's gone to the point of negilibility. There is a small linear decay until it reaches zero to cut down on math when no action is taken.
            let squishFactor = getCurrentSquish(location);
            // squishFactor += boxFoxData[i].tempSquishMagnitude * Math.cos(boxFoxData[i].tempSquishAngle);
            boxFoxData[location].tempSquishAngle *= 0.25 ** (1 / framesPerSecond);
            boxFoxData[location].tempSquishMagnitude *= 0.25 ** (1 / framesPerSecond);
            if (foxIsSquishy) {
                foxGroup.setAttribute("transform", "scale(" + squishFactor + " " + 1 / squishFactor + ")");
            } else {
                applySquish(location, squishFactor);
            }


            //The temporary and permanent squish is *beautiful* for T1 foxes. I will have to see how it works out when only the booba squishes and not the fox themselves.
        }
    }
    function advanceTime(delta) {
        newFoxProgress += delta
    }

    function renderFrame() {
        newFoxProgress += 1 / framesPerSecond;
        newMergeProgress += 1 / framesPerSecond;
        time += 1 / framesPerSecond;
        var foxProgressBar = document.getElementById("foxProgressBar");
        //ProgressBar.style.backgroundColor = "rgb(" + Math.max(255 * Math.cos((Math.PI / 4) * NewFoxProgress / NewFoxTime)) + ", " + Math.max(255 * Math.sin((Math.PI / 4) * NewFoxProgress / NewFoxTime)) + ", 0)";
        foxProgressBar.style.backgroundColor = "rgb(" + Math.max(255 - 255 * newFoxProgress / newFoxTime) + ", " + Math.max(255 * newFoxProgress / newFoxTime) + ", 0)";
        foxProgressBar.style.width = newFoxProgress * 100 / newFoxTime + "%";

        var mergeProgressBar = document.getElementById("mergeProgressBar");
        //ProgressBar.style.backgroundColor = "rgb(" + Math.max(255 * Math.cos((Math.PI / 4) * NewFoxProgress / NewFoxTime)) + ", " + Math.max(255 * Math.sin((Math.PI / 4) * NewFoxProgress / NewFoxTime)) + ", 0)";
        mergeProgressBar.style.backgroundColor = "rgb(" + Math.max(255 - 255 * newMergeProgress / newMergeTime) + ", " + Math.max(255 * newMergeProgress / newMergeTime) + ", 0)";
        mergeProgressBar.style.width = newMergeProgress * 100 / newMergeTime + "%";

        if (newFoxProgress > newFoxTime) {
            let foxTier = Math.floor(Math.random() * biggestFoxCreated + 1);
            let foxLayer = Math.floor((foxTier - 1) / 7);
            if (emptyBoxes[foxLayer].length != 0) {
                newFoxProgress = 0;
                var boxChosen = emptyBoxes[foxLayer][Math.floor(Math.random() * emptyBoxes[foxLayer].length)];
                emptyBoxes[foxLayer].splice(emptyBoxes[foxLayer].indexOf(boxChosen), 1);
                if (!document.getElementById("foxBox" + boxChosen).hasChildNodes()) {
                    boxTiers[boxChosen] = foxTier;
                    createFox(boxChosen);
                    newFoxProgress = 0;
                } else {

                    console.log(boxChosen)
                    console.log(emptyBoxes)
                }
            } else {
                newFoxProgress = newFoxTime;
            }
        }

        if (newMergeProgress > newMergeTime) {
            if (mergeMightWork) {
                let tierArray = [];
                for (let i = 1; i <= maxMergeTier; i++) {
                    if (i % 7 == 0) {
                        if (emptyBoxes[i / 7].length != 0) {
                            tierArray.push(i);
                        }
                    } else {
                        tierArray.push(i);
                    }
                    //This check will prevent the top tier within a layer from being chosen if there's no room on the following layer.
                }
                let selectedBoxes = []
                while (selectedBoxes.length == 0 && tierArray.length > 0) {
                    let currentSelection = tierArray.splice(Math.floor(Math.random() * tierArray.length), 1)[0];
                    //console.log(currentSelection)
                    if (boxTiers.filter(x => x === currentSelection).length > 1) {
                        for (const location in boxTiers) {
                            if (boxFoxData[location].isDangling == 0 && boxTiers[location] == currentSelection && boxFoxData[location].isTargeted == 0) {
                                selectedBoxes.push(location)
                            }
                        }
                        if (selectedBoxes.length >= 2) {
                            //Multiple non-dangling foxes of a given tier have been found.
                            while (selectedBoxes.length > 2) {
                                selectedBoxes.splice(Math.floor(Math.random() * selectedBoxes.length), 1);
                                //Clears all but two of them
                            }
                            if (Math.random() < 0.5) {
                                selectedBoxes.push(selectedBoxes.splice(0, 1)[0]);
                            }

                        } else {
                            selectedBoxes = []
                        }
                    }
                }
                if (selectedBoxes.length == 2) {
                    newMergeProgress = 0;
                    createMovingFox(selectedBoxes[0], selectedBoxes[1]);
                } else {
                    mergeMightWork = 0;
                    newMergeProgress = newMergeTime;
                }
            } else {
                newMergeProgress = newMergeTime;
            }

            //This code's a little too heavy to run every tick while there's no available merges. After a check is failed, it sets mergeMightWork to 0 and will skip future checks unless something has changed since.

        }


        //To convert from layers to the highest box in said layer, you need 9 + (layer) * 8
        for (let i = Math.max(0, (Math.ceil(properZoomLevel) - 3) * 8); i <= Math.min((Math.ceil(properZoomLevel) + 2) * 8,boxTiers.length-1); i++) {
              updateLayingSquish(i);
          // This is the squish over time. For testing the holding offset, it can be commented out. Abooga.
        }
        //Above is the squish for laying foxes. Below is the squish for hanging foxes.
        //The laying fox squish is only updated each frame if it's within 3 layers of the current viewed layer (or the next lae)
        for (const location in boxFoxData) {
            if (boxFoxData[location].isDangling == 1) {
                if (boxFoxData[location].movingToTarget != -1) {
                    if (boxFoxData[location].movingToTarget == heldFoxLocation) {
                        boxFoxData[location].movingToTarget = location;
                        //If the player picks up a fox that's being targeted, they're returned to where they started.
                        let targetRect = document.getElementById("foxBox" + boxFoxData[location].movingToTarget).getBoundingClientRect();
                        boxFoxData[location].holdingOffsetX += -((targetRect.left + targetRect.right) / 2 + 1) + boxFoxData[location].heldPointX;
                        boxFoxData[location].holdingOffsetY += -(targetRect.bottom - boxFoxData[boxFoxData[location].movingToTarget].initialHangPointLength * zoomFactorY(boxFoxData[location].movingToTarget)) + boxFoxData[location].heldPointY;
                    }


                    let targetRect = document.getElementById("foxBox" + boxFoxData[location].movingToTarget).getBoundingClientRect();
                    //boxFoxData[location].holdingOffsetX -= ((targetRect.left + targetRect.right) / 2 + 1) + boxFoxData[location].heldPointX;
                    //boxFoxData[location].holdingOffsetY -= (targetRect.bottom + boxFoxData[boxFoxData[location].movingToTarget].restingCenterHeight * 1.1 * zoomFactorY(boxFoxData[location].movingToTarget)) + boxFoxData[location].heldPointY;

                    boxFoxData[location].heldPointX = (targetRect.left + targetRect.right) / 2 + 1;
                    boxFoxData[location].heldPointY = targetRect.bottom - boxFoxData[location].initialHangPointLength * zoomFactorY(boxFoxData[location].movingToTarget);

                    document.getElementById("hangingFox" + location).setAttribute("viewBox", -boxFoxData[location].heldPointX + " " + (-boxFoxData[location].heldPointY + 0.3) + " " + window.innerWidth + " " + window.innerHeight);
                }

                updateFoxPhysics(location);
              //Abooga. This word is used with ctrl+f to find the things I really need to remember to uncomment when I'm done testing stuff.

                if (boxFoxData[location].holdingOffsetX ** 2 + boxFoxData[location].holdingOffsetY ** 2 < 0.3 && (boxFoxData[location].movingToTarget != -1)) {
                    putFoxDown(location)
                    //Add something to instantly align the foxes to the location of their destination when they're being put down so that they never miss.
                }
            }
        }









        //Below this point all zooming is handled.


        if (currentlyZooming) {
            updateZoom()

        }


        //This entire for loop is used to detect any potential errors with boxes, and whether something invisible takes their place, and so on. If any of these messages appear in the console (ctrl+shift+i), that means something did go wrong, but it fixed it.
        //Ideally, nothing should go wrong, so even if this fixes it, it would be better to resolve the bug at the source. Do let me know the circumstances if anything triggers this block.
        for (i = 0; i < boxTiers.length; i++) {
            if (document.getElementById("foxBox" + i).getElementsByClassName("wholeFox")[0]) {
                //If the box has a fox in it.
                if (emptyBoxes[foxLayer(i)].includes(i)) {
                    emptyBoxes[foxLayer(i)].splice(emptyBoxes[foxLayer(i)].indexOf(i), 1)
                    console.log("box " + i + "had a fox but was considered empty")
                    //If it's considered an empty box despite having a fox in it, it's an error.
                }
            } else {
                if (emptyBoxes[foxLayer(i)].includes(i) || boxFoxData[i].isReserved != undefined) {
                    if (boxFoxData[i].isReserved != undefined) {
                        if (boxFoxData[boxFoxData[i].isReserved].isDangling == 0) {
                            console.log("box " + boxFoxData[i].isReserved + " was reserving box " + i + " but wasn't moving.")

                            emptyBoxes[foxLayer(i)].push(i)
                            boxFoxData[i].isReserved = undefined;
                        }
                    }
                    //All good, it's empty and is in the right places. Or is reserved.
                } else {
                    console.log("box " + i + " was empty but was not considered such. If you can see this, the issue was fixed, but you should still let the developer know that something's going wrong.")
                    //  console.log(emptyBoxes)
                    //  console.log(boxFoxData[i])
                    //  clearInterval(ticker)
                    //  emptyBoxes[foxLayer(i)].push(i)

                }
            }

        }

        //This is the end of the frame rendering function.
    }

    document.addEventListener('keydown', (event) => {
        // Check which key was pressed
        const keyPressed = event.key;

        // Do something based on the pressed key
        switch (keyPressed) {
            case "q":
                zoomIn()
                break;
            case "e":
                zoomOut()
                break;
            case "w":
                zoomUp()
                break;
            case "s":
                zoomDown()
                break;
            case "a":
                zoomLeft()
                break;
            case "d":
                zoomRight()
                break;
        }
    });

    function updateZoom() {
        if (targetZoomLevel > layersUnlocked) {
            targetZoomLevel = layersUnlocked;
        }
        /*if (layersUnlocked - zoomLevel < 1) {
            zoomX = Math.min(zoomX, (layersUnlocked - zoomLevel));
            zoomY = Math.min(zoomY, (layersUnlocked - zoomLevel));
            
        }*/
        //The above block is meant to clamp the topmost layer so that it can't be used to view outside the unlocked area. I'll probably just have to not affect the data at all and just clamp it while rendering (with something to set the targets to 0 when it won't change anything).
        //Clamp the translations to a max of 2.

        //var nextLayerProgress = Maybe something to plot the exponential scaling so that other things can follow it?
        //Maybe none of this is necessary and all I need to do is ensure that 
        

        properZoomLevel += (targetZoomLevel - properZoomLevel) * (1 - 0.01 ** (1 / framesPerSecond));
        /*if (Math.abs(zoomLevel - targetZoomLevel) < 0.001) {
            properZoomLevel = targetZoomLevel;
        }*/

            zoomX += (targetZoomX - zoomX) * (1 - 0.01 ** (1 / framesPerSecond));
            zoomY += (targetZoomY - zoomY) * (1 - 0.01 ** (1 / framesPerSecond));
            
        /*if (Math.abs(zoomX - targetZoomX) < 0.001) {
            zoomX = targetZoomX;
        }
        if (Math.abs(zoomY - targetZoomY) < 0.001) {
            zoomY = targetZoomY;
        }*/

        if (focusOnFox != undefined) {
            focusZoomLevel += (targetZoomLevel + 1 - focusZoomLevel) * (1 - 0.01 ** (1 / framesPerSecond / (targetZoomLevel + 1.1))); //It settles in at targetZoomLevel + 1, but of course it's negative in every place it's used.
        } else {
            focusZoomLevel -= focusZoomLevel * (1 - 0.01 ** (1 / framesPerSecond));
        }

        if ((targetZoomLevel == zoomLevel) && (targetZoomX == zoomX) && (targetZoomY == zoomY)) {
            //currentlyZooming = 0;
        }
        zoomLevel = properZoomLevel - focusZoomLevel
        var focusProgress = focusZoomLevel / (Math.max(targetZoomLevel, 0) + 1)
        var limitedFocusProgress = 1 / (Math.max(targetZoomLevel, 0) + 1)

        function focusHeightTrack() {
            if (focusOnFox != undefined) {
                if (boxFoxData[focusOnFox].isDangling != 1) {
                    let realRestingCenter = ((boxFoxData[focusOnFox].restingCenterHeight - boxFoxData[focusOnFox].raiseFactor) * zoomFactorY(focusOnFox, 0) + boxFoxData[focusOnFox].raiseFactor);
                    focusRestingHeight = -((boxFoxData[focusOnFox].raiseFactor) * getSizeMultiplier(boxTiers[focusOnFox]) / getCurrentSquish(focusOnFox)) //* (146/150) //* ((0.06 + boxFoxData[focusOnFox].tempSquishMagnitude) * Math.cos(Math.PI * 2 * time / 1.7 - focusOnFox / 9 - boxFoxData[focusOnFox].tempSquishAngle)) * getSizeMultiplier(boxTiers[focusOnFox])


                }
                
               
                

            }
            return focusRestingHeight;
        }


        


        
        for (const wrapper of document.getElementsByClassName("foxLayerWrapper")) {

            let layerTier = wrapper.id.replace("foxLayerWrapper", "") * 1;
            //Remember to put an if statement here to make it stop zooming out if it's already out of sight
            if (layerTier > properZoomLevel + 2 || (layerTier < properZoomLevel && (zoomX < -1 || zoomY > 1))) {
                //If any layer is guaranteed to not be visible, it's hidden to save on rendering power.
                wrapper.style.display = "none"
            } else {
                wrapper.style.display = "block"
                

                //what has to happen is that zoomX/Y + 1 cannot exceed ((49/15) ** (zoomLevel - layerTier) / (49/15))


                //wrapper.style.transform = " translate(" + (260 * 19 / 6 * -(Math.min(-zoomX + 1, (6 / 19) ** (zoomLevel - layerTier)) - 1)) + "px ," + (170 * 49 / 15 * (Math.min(zoomY + 1, (15 / 49) ** (zoomLevel - layerTier)) - 1)) + "px) scale(" + ((6 / 19) ** (zoomLevel - layerTier)) + "," + ((15 / 49) ** (zoomLevel - layerTier)) + ")";
                //Overall, doesn't work. Too much layer juggling and the end result isn't visually appealing.

                //if (focusOnFox == undefined) {
                if (focusZoomLevel < 1 || experimentalZoom == 0) {
                    wrapper.style.transform = "translate(" + ((260 * (zoomX) - (1 - (6 / 19) ** focusZoomLevel) * 120) * (19 / 6) ** (focusZoomLevel + 1)) + "px ," + ((170 * zoomY) * (49 / 15) ** (focusZoomLevel + 1) - 7.513 * (1 - (49 / 15) ** (focusZoomLevel)) +  /*(1 - (15 / 49) ** (focusZoomLevel ** 2)) **/ focusHeightTrack() * ((49 / 15) ** (focusZoomLevel + 1) + 49 / 15 * (-1 + focusProgress)) - 200 * focusProgress) + "px) scale(" + ((6 / 19) ** (zoomLevel - layerTier)) + "," + ((15 / 49) ** (zoomLevel - layerTier)) + ")";
                    if (foxViewBox != undefined) {
                        foxViewBox.baseVal.height = 146;
                        foxViewBox.baseVal.y = -145.7;
                        foxViewBox.baseVal.width = 236;
                        foxViewBox.baseVal.x = -118;
                    }
                } else {
                    wrapper.style.transform = "translate(" + ((260 * (zoomX) - (1 - (6 / 19) ** 1) * 120) * (19 / 6) ** (1 + 1)) + "px ," + ((170 * zoomY) * (49 / 15) ** (1 + 1) - 7.513 * (1 - (49 / 15) ** (1)) +  /*(1 - (15 / 49) ** (focusZoomLevel ** 2)) **/ focusHeightTrack() * ((49 / 15) ** (1 + 1) + 49 / 15 * (-1 + limitedFocusProgress)) - 200 * limitedFocusProgress) + "px) scale(" + ((6 / 19) ** (zoomLevel + focusZoomLevel - 1 - layerTier)) + "," + ((15 / 49) ** (zoomLevel + focusZoomLevel - 1 - layerTier)) + ")";
                    //This prevents the entire shaboozle from actually zooming in past 1 layer when it's focused. This is enough to hide the edges of the div. Beyond that, it's better for "too many orders of magnitude" rendering if viewport manipulation is done instead. Probably. Hopefully.
                    foxViewBox.baseVal.height = 146 * ((15 / 49) ** (focusZoomLevel - 1))
                    foxViewBox.baseVal.y = -focusHeightTrack() - (145.7 - focusHeightTrack()) * ((15 / 49) ** (focusZoomLevel - 1))
                    foxViewBox.baseVal.width = 236 * ((6 / 19) ** (focusZoomLevel - 1))
                    foxViewBox.baseVal.x = -118 * ((6 / 19) ** (focusZoomLevel - 1))
                    console.log(focusHeightTrack())
                }
                


                //The theoretical correct value for the bottom offset is 7.513. If changing it fixes everything, do that, but otherwise return it to what it needs to be.



                //If I don't want the fox display bricking entirely when zoomed in, I need to adjust the viewport once the div itself is hidden.



            }
            //wrapper.style.transform = "scale(" + ((6 / 19) ** (zoomLevel - layerTier)) + "," + ((15 / 49) ** (zoomLevel - layerTier)) + ")";
        }
    }


    function checkButtons() {
        if (targetZoomLevel != layersUnlocked) {
            document.getElementById("buttonZO").classList.add("activeButton")
        } else {
            document.getElementById("buttonZO").classList.remove("activeButton")
        }
        if (targetZoomLevel > -1 && focusOnFox == undefined) {
            document.getElementById("buttonZI").classList.add("activeButton")
        } else {
            document.getElementById("buttonZI").classList.remove("activeButton")
        }


        if (targetZoomY < 2 && targetZoomLevel != layersUnlocked && focusOnFox == undefined) {
            document.getElementById("buttonZU").classList.add("activeButton")
        } else {
            document.getElementById("buttonZU").classList.remove("activeButton")
        }

        if (targetZoomY > 0 && targetZoomLevel != layersUnlocked && focusOnFox == undefined) {
            document.getElementById("buttonZD").classList.add("activeButton")
        } else {
            document.getElementById("buttonZD").classList.remove("activeButton")
        }

        if (targetZoomX < 0 && targetZoomLevel != layersUnlocked && focusOnFox == undefined) {
            document.getElementById("buttonZL").classList.add("activeButton")
        } else {
            document.getElementById("buttonZL").classList.remove("activeButton")
        }
        if (targetZoomX > -2 && targetZoomLevel != layersUnlocked && focusOnFox == undefined) {
            document.getElementById("buttonZR").classList.add("activeButton")
        } else {
            document.getElementById("buttonZR").classList.remove("activeButton")
        }

        if (targetZoomX != 0 || targetZoomY != 0 || (targetZoomLevel == -1)) {
            document.getElementById("infoBox").classList.remove("infoIn");
            document.getElementById("infoBox").classList.add("infoOut");
            updateInfo(boxTiers[(2 + targetZoomX) + (3 * (2 - targetZoomY)) + (8 * (targetZoomLevel + 1)) + (targetZoomLevel > -1)])
        } else {
            document.getElementById("infoBox").classList.remove("infoOut");
            document.getElementById("infoBox").classList.add("infoIn");
        }


    }

    function updateInfo(fox) {
        //Here's the table for the fox values. Obviously, it'll be massive. Make it a switch statement, but keep things like Tier at the top procedural.
        //First is Tier, then cup size, then weight, then notes.
        document.getElementById("infoBox").innerHTML = fox + "<br \\><br \\>There'll be more lore and such here when I get around to writing it all. You'll just have to use your imagination for now. Think of the possibilities!"
        if (fox == 69) {
            document.getElementById("infoBox").innerHTML += "<br \\><br \\>Also, nice."
        }
        //Need to remember to make this function also trigger when the fox in the box you're looking at changes- usually through automerge or spawning.
    }



    checkButtons()

    function zoomOut() {
        if (focusOnFox != undefined) {
            focusOnFox = undefined
        } else {
            if (targetZoomLevel != layersUnlocked) {
                targetZoomLevel += 1;
                currentlyZooming = 1;
            }
            if (targetZoomX != 0 || targetZoomY != 0) {
                targetZoomX = 0;
                targetZoomY = 0;
            }
        }
        checkButtons()
    }

    function zoomIn() {
        if (targetZoomX == 0 && targetZoomY == 0 && targetZoomLevel > -1) {
            targetZoomLevel -= 1;
            currentlyZooming = 1;
            
        } else {
            if (targetZoomLevel > -1) {
                focusOnFox = (2 + targetZoomX) + (3 * (2 - targetZoomY)) + (8 * (targetZoomLevel + 1)) + (targetZoomLevel > -1);
                if (boxTiers[focusOnFox] == 0) {
                    focusOnFox = undefined;
                } else {
                    foxViewBox = document.getElementById("fox" + focusOnFox).viewBox
                }
                console.log(focusOnFox)
            }
        }
        checkButtons()
    }

    function zoomUp() {
        if (targetZoomY < 2 && targetZoomLevel != layersUnlocked && focusOnFox == undefined) {
            targetZoomY += 1;
            currentlyZooming = 1;
            checkButtons()
        }
    }

    function zoomDown() {
        if (targetZoomY > 0 && targetZoomLevel != layersUnlocked && focusOnFox == undefined) {
            targetZoomY -= 1;
            currentlyZooming = 1;
            checkButtons()
        }
        
    }

    function zoomLeft() {
        if (targetZoomX < 0 && targetZoomLevel != layersUnlocked && focusOnFox == undefined) {
            targetZoomX += 1;
            currentlyZooming = 1;
            checkButtons()
        }
    }

    function zoomRight() {
        if (targetZoomX > -2 && targetZoomLevel != layersUnlocked && focusOnFox == undefined) {
            targetZoomX -= 1;
            currentlyZooming = 1;
            checkButtons()
        }
    }

    function normalMode() {
        newMergeTime = 10;
    }

    function quickMode() {
        newMergeTime = 100000000000000000000000000;
    }

    function sillyMode() {
        newFoxTime = 0.1;
        newMergeTime = 0.2;
    }

    function updateHangingSquish(location) {
        targetX = boxFoxData[location].heldPointX
        targetY = boxFoxData[location].heldPointY

        let newBoobDeltaX = (boxFoxData[location].hangPointX - (targetX + boxFoxData[location].holdingOffsetX)) / zoomFactorX(location);
        let newBoobDeltaY = (boxFoxData[location].hangPointY - (targetY + boxFoxData[location].holdingOffsetY)) / zoomFactorY(location);
        let newBoobAngle = angleDistillation(newBoobDeltaX, newBoobDeltaY);
        let newBoobMagnitude = ((newBoobDeltaX ** 2 + newBoobDeltaY ** 2) ** 0.5) / boxFoxData[location].initialHangPointLength;
        if (newBoobMagnitude > 1.5) {
            boxFoxData[location].hangPointX = Math.cos(newBoobAngle) * boxFoxData[location].initialHangPointLength * 1.5 * zoomFactorX(location) + (targetX + boxFoxData[location].holdingOffsetX);
            boxFoxData[location].hangPointY = Math.sin(newBoobAngle) * boxFoxData[location].initialHangPointLength * 1.5 * zoomFactorY(location) + (targetY + boxFoxData[location].holdingOffsetY);
        } else if (newBoobMagnitude < 0.6) {
            boxFoxData[location].hangPointX = Math.cos(newBoobAngle) * boxFoxData[location].initialHangPointLength * 0.6 * zoomFactorX(location) + (targetX + boxFoxData[location].holdingOffsetX);
            boxFoxData[location].hangPointY = Math.sin(newBoobAngle) * boxFoxData[location].initialHangPointLength * 0.6 * zoomFactorY(location) + (targetY + boxFoxData[location].holdingOffsetY);
        }
        //The above portion rectifies the boob if it's outside the allowed margins.





        let boobDeltaX = (boxFoxData[location].hangPointX - targetX - boxFoxData[location].holdingOffsetX) / zoomFactorX(location);
        let boobDeltaY = (boxFoxData[location].hangPointY - targetY - boxFoxData[location].holdingOffsetY) / zoomFactorY(location);

        let boobAngle = angleDistillation(boobDeltaX, boobDeltaY) * 180 / Math.PI - 90,
            boobMagnitude = boxFoxData[location].initialHangPointLength / ((boobDeltaX ** 2 + boobDeltaY ** 2) ** 0.5);


        var transformation = ""

        transformation += "translate(" + boxFoxData[location].holdingOffsetX + ", " + boxFoxData[location].holdingOffsetY + ")";
        transformation += "rotate(" + boobAngle + ")";
        transformation += "scale(" + zoomFactorX(location) + " " + zoomFactorY(location) + ")";
        if (foxIsSquishy) {
            transformation += "scale(" + boobMagnitude + " " + 1 / boobMagnitude + ") "
        } else {
            applySquish(location, boobMagnitude);
        }
        document.getElementById("hangingFoxBox" + location).getElementsByClassName("wholeFox")[0].setAttribute("transform", transformation);





    }



    /*Todo list:


    - if a lower tier is entirely filled, the creation function will just retry until the rolled value fits the open boxes, causing the average to be much higher than it should. Once a created tier is rolled, it's kept until it successfully creates one.

    - Use the runge-kutta method to significantly reduce the error of the jiggle so that I can further decrease friction.

    - See about transitioning from transformations to viewport manipulation when focusing on foxes. Do this by finding a way to adjust the edges of the viewport to keep the fox's head perfectly centered.

    - Make automerges that begin on tiers above yours happen instantly, no animation.
The associated and sufficient transform is as follows:
transform-origin: bottom left;
transform: scale(calc(4/13),calc(5/17));
Nope the actual scale is 6/19, 15/49. This has the side effect of being able to zoom into one specific fox at any time. Groovy.
Apply this to the wrap element and raise those fractions to the power of how small it is and yer golden.
All I need to do now is create a method of segmenting the foxes into their areas and ensuring that they don't get misplaced. Probably will involve turning the emptyBoxes array into a nested array or the like, and ensuring that holding a fox prevents clicking buttons, and area transitions prevent holding foxes.


Immediate Plan:

Done! Create a system for procedurally handling foxes moving by themselves:
      - The the fox removes its own onclick (it can't be interrupted)
      - The fox adds a consideration to its data that it's moving. Its box and its destination can't be interacted with mid-move, so it has to be very quick.


Done! The smaller area will zoom out to reveal the larger one. The smaller area will be in the bottom-left box. It will have no bounding box (the outerFoxBox will remain stationary throughout the game). An invisible grouping div surrounds all the boxes of a given area, and acts like an inner box of the larger area for grouping purposes. Maybe? Just an idea.
     The transformation doesn't preserve the aspect ratio. It will be slightly skewed so that larger/smaller areas are squashed and stretched so all the box sizes match.
     All larger areas will remain just 1 size larger than the visible one, the next one shrinking down as necessary. The smaller areas will have to deal. The scaling center will have to be the bottom-left corner of the bottom-left foxbox.

Done! Maybe try to make friction only apply to the force along the cleavage line? Maybe just to a lesser extend perpendicular to it. The slowdown when spinning is preventing many a funny time.

Done! Create a T7 fox model and figure out how it'll wobble. Current idea is to alternate between V and ^, raising the middle while lowering the sides, and vice versa. All points beneath a little under halfway won't move (and be shaped around the lower bevel of the box).

Done! When the fox is picked up, tweak the cursor offset that decays so that it accounts for the fox's current level of squish.

Done! Make it mobile compatable. There's two portions to that: The first is preventing the SVG from overflowing the area of the screen, however it's doing that. The second is getting the aspect ratio so it can't drag, but is fully visible on landscape mode.'

Done! To the eachFrame function, right about next to where the fox squish is calculated, add a function that determines the angle and squish level based on the data (just pythagorean theorem and arctan to get angle+magnitude) and correspondingly applies them to the held fox, if a fox is held.
When the fox is clicked, it starts off vertical on the very first frame and quickly + smoothly moves to the cursor, boob momentum as it will. The Holding offset will have to be created in the way that the current hanging point is, then divided each second. Simple enough methinks.
Perhaps I will want to do the same when the fox is deposited; find some way to move her smoothly to the center of the box rather than teleporting.

Done! Adjust the Envelope function to be given a fox and squish factor, read the fox's tier to find the corresponding template, and move bit by bit through the paths to set them to their new values.
A class marks the paths in which the x-values of the endpoints don't change; as in the boob paths. The y-values will still change fine. The rise/fall values of the body will be determined by the first point on the body, that being one of the points that connect to the boob.

- Import the first six resting fox sizes. Create a way to store each of their inertias and whatnot. The passive wobble and active jiggle is stored separately and stacked on top of each other.
- Import the first six held fox sizes. Create a secondary mass point that centers/rotates the fox, squashing and stretching them in the process.
- Allow for tiers greater than 6 via new areas. Allow transitioning between them, but prevent foxes from being dragged/created across areas.
- Create a questbox that accepts foxes and rewards slightly increased stats (fox rate, higher tier fox chance, auto fox combine rate + limit). Some quests require a specific size, and some scale their reward based on the delivered fox.
- Maybe make some background art for the areas. It will now have to be positioned in a way that it is *not* a child node of the fox boxes. However, with transparency that is quite easy.

Notes:

I won't make the foxes of each tier unique. I'll just add a compendium or an info tab that appears when you fully zoom in on a fox.

Allow the player to use the zoom function to view single foxes at a time. Perhaps also place the info of each fox tier there as well.
When picking up a fox, determine its scale level and adjust the SVG appropriately, initialHangPoint included. Calculations using the hangpoint will have to use it multiplied by the current scaling factor, inverse to the SVG scale.
Rather than using tier-based momentum, make it scale based off of the initialHangPoint. May not be necessary.

Make the foxes placed where the mouse cursor is horizontally and slide over to the center over time. This doesn't apply to the T7 foxes. Consider trying to implement other locations, or perhaps backgrounds.

I can probably make the area issue simple by having the larger box be given the "currentArea" tag and only searching within the child nodes of that larger box. With the id requirement as well, that makes it so I can still fit an SVG background in there.
The SVG of the held fox doesn't need to rotate, I can just group the whole thing and manipulate that.
A guy offered to make music. For this game in particular, that's not completely nonsense. It will be a lil questionable if I can make it at all interactive, though.
Higher tier fox chance quests are delivered in increments of 5% of the previous fox's chance, up to a max of 90%. Each percentage is just the chance to bump it one tier higher (and roll again, if possible). Only 1 chance upgrade is offered per color for each fox tier.

It goes up to T7 in each area. 1 1 2 3 4 5 6 7 is the numbers required to advance, which is 8, leaving one for, I dunno, quests or smth.
T7 is smushed against the edges of the box. The nips are outside the edge, which can only be made possible by having a separate white triangle with a beveled corner in the area where the squish would ruin the bevel, located outside of the "wholeFox" group. I dunno. Maybe not. Still want there to be a T7 though.

Put up a setting that lets you choose between the fox squishing with the booba or the fox remaining rigid.

Consider whether transforming the SVG object itself or the group within it is better for performance.

You can store 1 quest at a time, but you can skip em if you want. They come back on a very short cooldown. The important ones are tracked by completion rather than offering so they'll come back. Cost can be from T1 to current highest tier, rewards can be anywhere from the required tier to T1. Some quests will be bad, but that's a feature.
Quest cooldown is 20 seconds regardless of if it was completed or skipped.
The quest box appears as soon as the first T3 fox is created via animations.
The arrangement on desktop is foxgrid in center, smaller area on the bottom left, larger area on the right, Stats below the bar, and quests on the top left.

Tip: The process of combining two foxes involves convincing one to grope the other, causing the latter's breasts to grow and the former to be smothered by them for the forseeable future. It is not hard to convince them to do this.
Tip: Some quests just aren't worth the rewards they give. You can skip a quest with the button at the top.

Use the envelope function, and find a better way to select the foxes.

Quest reward limits are as follows:
- +1 fox per minute per (Tier - 2)
- +10% (multiplicative) chance to get the (Tier - 3) fox instead of its previous upgrade
- +1 combine per minute per (Tier - 4)
- +1 combine limit up to (Tier - 5) (This one will always be unique + guaranteed to have max cost/reward.)

Quest ideas:
- "Our band' was looking for a gimmick to help us stand out. Do you have any ideas?" (T11 or so) "They never did specify *how* we had to fill those seats. Groovy."
- "Our band struck it big! Maybe a bit too big. The next gig has us playing halftime at the football stadium down the way and we need to give them a show you won't forget." (T20 or so) "This'll make a splash. If we can manage to roll her over there."
- "I suffer from a chronic condition where if my body temperature gets too cold I'll go into a coma. Only the warmth of phat titties around me can keep me alive." (T5 or so) "I live another day!"
- "My fox girlfriend came to the beach a few hours ago but I haven't been able to find her in a bit. Could you point me in her direction?" (T6) "Holy hell she's massive! What have you been *feeding* her?!"
- "I was thinking about opening a boba stall around here, but milk tea's expensive to make. If I had a fox to help me with sourcing ingredients, though..." (T4) "She's perfect! Stop by sometime, first cup's on me!" (higher initial fox tier percentage)


    */
</script>
        </body>
        </html>
